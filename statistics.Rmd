---
title: "Bias Partion Manuscript"
subtitle: "Statistical analysis"
author: "A.M. Piper"
date: "`r Sys.Date()`"
output: 
  html_document:
    highlighter: null
    theme: "flatly"
    code_download: true
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    df_print: paged    
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

# Introduction

* Comparisons of models
* Bias prediction using cofactors
  + Once bias has been partitioned to its relevant stage, we can accurately predict things
  + Can Extraction bias be predicted by scheletorization?
  + Can PCR bias be predicted by amplicon GC content, or primer binding mismatch?
  + Can library bias be predicted by PCR barcode?
  

Extra comparisons:
* Modelling of bias from # individuals vs biomass
* Modelling of contribution on partitioned vs non-partitioned bias
  + This would allow making a point that you need to partition biases to accurately improve protocols 


## Load packages
```{r load packages}
#Set required packages
.cran_packages <- c("tidyverse",
                    "tidymodels",
                    "janitor",
                    "vip",
                    "patchwork", 
                    "vegan", 
                    "seqinr",
                    "ape", 
                    "RColorBrewer",
                    "devtools",
                    "ggthemes")
.bioc_packages <- c("dada2",
                    "phyloseq", 
                    "DECIPHER",
                    "Biostrings",
                    "ShortRead", 
                    "ALDEx2")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("mikemc/metacal")
devtools::install_github("alexpiper/taxreturn")
devtools::install_github("r-lib/conflicted")

library(metacal)
library(taxreturn)

#Source helper functions
source("R/helper_functions.R")
```

# Set a colour scheme & Define theme

```{r pick colours}
colours.taxon <- c(
  "Acizzia_alternata" = "#A6CEE3",
  "Acizzia_solanicola" = "#438FC0",
  "Aphidius_colemani" = "#808080",
  "Bactrocera_tryoni" = "#000000",
  "Bradysia_nr.ocellaris" = "#FFFF00",
  "Carpophilus_davidsoni" = "#9AD378",
  "Carpophilus_nr.dimidiatus" = "#3EA534",
  "Diuraphis_noxia" = "#B29C71",
  "Drosophila_hydei" = "#F26B6B"  ,
  "Drosophila_melanogaster" = "#E52823",
  "Drosophila_simulans" = "#FE9C32",
  "Lysiphlebus_testaceipes" = "#F08C3A",
  "Metopolophium_dirhodum" = "#CAB2D6",
  "Psyllid_sp" = "#000080",
  "Rhopalosiphum_padi" = "#FF00FF",
  "Scaptodrosophila_lativittata" = "#800080"
) 


#Source themes
source('R/themes.R')
```

# Read in data & get summary statistics

```{R read in}
counts <- read_csv("R_analysis/FILE_for_R_NEW.csv") %>%
  janitor::clean_names() %>%
  dplyr::mutate(sample_id = paste0(sample, "_", run),
                mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  TRUE ~ mixture_type
                  ),
                target_subfragment = case_when(
                  str_detect(sample, "P1$") ~ "fwhF2-fwhR2n",
                  str_detect(sample, "P2$") ~ "fwhF2-HexCOIR4",
                )) %>% 
  mutate(taxon = taxon %>% 
            str_replace("_dimidiatus", "_nr.dimidiatus") %>%
            str_replace("hydeii", "hydei") %>%
            str_replace("Bradysia_ocellaris", "Bradysia_nr.ocellaris")) %>%
  dplyr::select(-table) 


# new counts
ps <- readRDS("output/rds/ps.rds")

newcounts <- ps %>%
  speedyseq::psmelt() %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(taxon, sample_id, Abundance, sample, fcid) %>%
  filter(Abundance > 0, !is.na(taxon)) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ))

combined_analysis <- counts %>% left_join(newcounts) %>%
  group_by(sample_id) %>%
  filter(!is.na(fcid)) %>%
  mutate(prop = Abundance) %>%
  mutate_at(c("prop"),  ~ . / sum(., na.rm = TRUE) )

# Check consistency between analyses
gg.combined_analyses <- combined_analysis %>% 
  dplyr::select(sample_id, taxon, prop, observed, fcid) %>%
  mutate(observed = observed / 100) %>%
  dplyr::rename(analysis1 = observed, analysis2 = prop) %>%
  pivot_longer(starts_with("analysis"),
               names_to="analysis",
               values_to="Abundance") %>%
  ggplot(aes(x = sample_id, y=Abundance, fill=taxon))+
  geom_col(position="stack") +
  facet_grid(analysis~fcid, scales="free", drop=TRUE) +
  scale_fill_manual(values=colours.taxon)+ 
  #scale_fill_brewer(palette="Paired") +
  base_theme +
  labs(x = "Sample", y="Relative Abundance", fill="Taxon")

gg.combined_analyses


# Replace old analysis with new
counts <- combined_analysis %>%
  dplyr::select(-observed, -count) %>%
  dplyr::rename(observed = prop, count = Abundance) %>%
  dplyr::mutate(observed = replace_na(observed, 0),
                count = replace_na(count, 0))

# Check all are proportions  
counts %>%
  group_by(sample, run) %>%
  summarise(exp = sum(expected), obs = sum(observed), count = sum(count))

# N unique species and samples
 counts %>%
  summarise(n_samples = n_distinct(sample), n_sequenced_samples = n_distinct(sample_id))

# Spread of reads
counts %>%
  group_by(sample_id) %>%
  summarise(exp_prop = sum(expected), obs_prop = sum(observed), Abundance = sum(count), run) %>%
  ungroup() %>%
  #group_by(run)%>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance),
            exp_prop = mean(exp_prop),
            obs_prop = mean(obs_prop))

```

## Add species traits

```{r biomass transform}
traits <- readxl::read_excel("biomass and hardness.xlsx")  %>%
  janitor::clean_names() %>%
  dplyr::rename(taxon = species) %>%
  filter(!is.na(taxon)) %>%
  dplyr::mutate(taxon = taxon %>%
                  str_replace("C\\.", "Carpophilus") %>%
                  str_replace("D\\.", "Drosophila") %>%
                  str_replace("A\\.", "Acizzia") %>%
                  str_replace("hydeii", "hydei") %>%
                  str_replace_all(" ", "_") %>%
                  str_remove_all("\\.")%>%
                  str_replace("nr_dimidiatis", "nr.dimidiatus")%>%
                  str_replace("Bradysia_ocellaris", "Bradysia_nr.ocellaris")

                  ) %>%
  dplyr::mutate(exoskeleton = as.numeric(exoskeleton))

# Plot measured traits
traits %>%
  pivot_longer(-c("taxon", "order"), 
               names_to = "trait",
               values_to = "value") %>%
  ggplot(aes(x=taxon, y=value, fill=order)) + 
  geom_col() +
  facet_grid(~trait) + 
  coord_flip() +
  scale_fill_brewer(palette="Paired")

#Check for differencess in taxon names
setdiff(traits$taxon, counts$taxon)
setdiff(counts$taxon, traits$taxon)

# Join tables together
joint <- counts %>%
  left_join(traits%>%
            mutate(taxon = taxon %>% str_replace("hydeii", "hydei")), by="taxon") %>%
  dplyr::mutate(exp_individuals = expected,
                exp_individuals = expected * biomass_mm3) %>%
  group_by(sample_id) %>%
    mutate_at(vars(exp_individuals, exp_individuals, observed), ~ . / sum(.) ) %>% #Convert back to proportions
  ungroup() %>%
  mutate(observed0 = (count + 0.5) * (expected > 0)) %>% #Add a pseudocount
  mutate(err_biomass = observed0 / exp_individuals,
         err_individuals = observed0 / exp_individuals) %>%
  ungroup() 

# Check if any werent properly joined
table(is.na(joint$exp_individuals))

# Plot expected individuals vs expected biomass
gg.p1 <- joint %>%
  dplyr::filter(target_subfragment=="fwhF2-fwhR2n") %>% #Filter to primer1
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - fwhR2n")

gg.p2 <- joint %>%
  dplyr::filter(target_subfragment =="fwhF2-HexCOIR4") %>% 
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - HexCOIR4")

gg.p1 + gg.p2
```

## Add sequence traits

```{r sequence traits}
# Get PHMM of full folmer region
coi_model <- readRDS("reference/folmer_fullength_model.rds")

primers <- tribble(
  ~Fname, ~Fprimer, ~Rname, ~Rprimer,
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "fwhR2n","GTRATWGCHCCDGCTARWACWGG",
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "HexCOIR4", "TATDGTRATDGCHCCNGC", 
  ) %>%
    left_join(.$Fprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, minscore=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("F",.)), by="Fprimer") %>%
    left_join(.$Rprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, minscore=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("R",.)), by="Rprimer")

# Read in sequences
seqs <- insect::readFASTA("reference/mock_spp2.fa")

# Add primers to seqs
primers.dna <- insect::char2dna(c("GGDACWGGWTGAACWGTWTAYCCHCC", rc("GTRATWGCHCCDGCTARWACWGG"),rc("TATDGTRATDGCHCCNGC")))
names(primers.dna) <- c("fwhF2", "fwhR2n", "HexCOIR4")

#Join to seqs
seqs <- c(seqs, primers.dna)

# Trim seqs to Fprimer bind region and get primer edit distance
aligned <- taxreturn::map_to_model(seqs, coi_model, minscore = 0, shave= TRUE, pad=TRUE, check_indels=FALSE, maxNs=Inf, cores=1, quiet=FALSE)

#Transform to DNAstringSet
aligned <- aligned %>% as.list %>% as.character %>% lapply(., paste0, collapse = "") %>% 
            unlist %>% DNAStringSet

# Check alignment
#BrowseSeqs(aligned)

#Get forward dist
Fprimerdist <- Biostrings::subseq(aligned, start=primers$Fstart[1], end = primers$Fend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Fprimer") %>%
  pivot_longer(cols=-Fprimer,
               names_to="taxon",
               values_to="Fdist") %>%
  filter(Fprimer=="fwhF2", !taxon %in% names(primers.dna)) %>%
  filter(Fdist < 0.5) #Filter bad alignments

#Get reverse dist
Rprimerdist <- bind_rows(
  #Rprimer1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[1]],
                     start=primers$Rstart[1], end = primers$Rend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="fwhR2n", !taxon %in% names(primers.dna)),
  #Rprimer2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[2]],
                   start=primers$Rstart[2], end = primers$Rend[2]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="HexCOIR4", !taxon %in% names(primers.dna))
)%>%
  filter(Rdist < 0.5) #Filter bad alignments

# get amplicon gc content
primergc <- bind_rows(
  #primer set 1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[1]],
                     start=primers$Fend[1]+1, end = primers$Rstart[1])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[1]]),
         target_subfragment = paste0(primers$Fname[1], "-", primers$Rname[1])) %>%
  dplyr::filter(!taxon %in% names(primers.dna)),
  #primer set 2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[2]],
                   start=primers$Fend[2]+1, end = primers$Rstart[2])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[2]]),
         target_subfragment = paste0(primers$Fname[2], "-", primers$Rname[2])) %>%
  dplyr::filter(!taxon %in% names(primers.dna))
)

joint <- joint %>%
  separate(target_subfragment, into=c("Fprimer", "Rprimer"), sep="-", remove=FALSE) %>%
  left_join(Fprimerdist) %>%
  left_join(Rprimerdist) %>%
  left_join(primergc) 
```


## Look at differences between runs

```{r run differences}
# Plot differences in quickextract - non-quickextract between runs
gg.runra <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
    ggplot(aes(x=sample, y=value, fill=taxon)) +
    geom_col(position="stack") +
    facet_grid(run~mixture_type, scales="free") +
    scale_fill_manual(values = colours.taxon) +
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_y_continuous(labels = scales::percent) +
    labs(x="Sample", y="Relative abundance")

# Plot as heatmap
gg.runhmap <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
  mutate(value = na_if(value, 0)) %>%
    ggplot(aes(x=sample, y=taxon, fill=value)) +
    geom_tile() +
    facet_grid(run~mixture_type, scales="free") +
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_fill_viridis_c(labels = scales::percent) +
    labs(x="Sample",
         y="Taxon",
         fill="Relative abundance")

gg.runcomparison <- gg.runra - gg.runhmap + plot_annotation(tag_levels="A")

gg.runcomparison

#Write out
pdf(file="figs/supplementary/run_comparison.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.runcomparison)
try(dev.off(), silent=TRUE)
  
# Remove the quickextract samples from run 2
joint <- joint %>%
  dplyr::filter(!(mixture_type=="QuickExtract" & run==2))
```

DNApools and PCR pools 1-4 and 5-8 arent exact replicates because of the extra species that were found

## Visualise bias

```{r visualise bias}
## Visualise errors in proportions
gg.err_prop <- joint %>% 
  mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(observed, exp_individuals, color = taxon)) + 
  geom_jitter(alpha=0.7) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  scale_colour_manual(values = colours.taxon) +
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Observed proportions (log-odds)", 
       y= "Expected proportions (log-odds)",
       colour = "Taxon") 

gg.err_prop

#Write out
pdf(file="figs/supplementary/err_proportions.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_prop)
try(dev.off(), silent=TRUE)

# Visualise the error in all pairwise ratios
gg.err_ratio <- joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  mutate(Pair = paste(Taxon.x, Taxon.y, sep = ":")) %>% 
  ggplot(aes(Pair, err_individuals, colour=sample_id)) +
  geom_jitter(alpha=0.7) +
  geom_hline(yintercept = 1) +
  scale_y_log10() +
  facet_grid(target_subfragment~mixture_type)+
    theme(legend.position = "none",
          axis.text.x = element_text(angle=45, hjust=1))+
  labs(y= "Error in taxon ratios (log10)") 

gg.err_ratio

#Save figure
pdf(file="figs/supplementary/err_ratio.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_ratio)
try(dev.off(), silent=TRUE)
  
# Get the average pairwise bias for each method
joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  group_by(mixture_type, target_subfragment) %>%
  summarise(mean = mean(err_individuals, na.rm=TRUE), sd = sd(err_individuals, na.rm=TRUE), lower = range(err_individuals, na.rm = TRUE)[1], upper = range(err_individuals, na.rm = TRUE)[2])
```


# Compare bias models

We will now estimate the bias using different conventional and CODA models

## Mean proportions

Here we estimate bias as the arithmetic mean of the error in proportions

```{r mean proportions}
# Compare these fits!  
fit_prop <- joint %>%
  filter(expected > 0) %>%
  mutate(error = observed / exp_individuals) %>%
  group_by(mixture_type, target_subfragment, taxon) %>%
  summarise(.pred = mean(error))

#results
prop_results <- joint %>%
  dplyr::filter(expected > 0) %>%
  left_join(fit_prop) %>%
  mutate(
    predicted =  exp_individuals * .pred, 
    observed = observed,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
```

## simple lm

Here we estimate bias using a simple linear regression model of the expected and observerd proportions. The model is fit seperately to each taxon and material type.


```{r simple lm}
# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm")
lm_spec

fit_lm <- joint %>%
  filter(expected > 0) %>%
  group_by(taxon, target_subfragment, mixture_type) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, observed ~ 0 + exp_individuals, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    ) %>%
  unnest(coef_info)

#results
lm_results <- fit_lm %>%
  unnest(pred, data) %>%
  mutate(
    predicted = .pred
  ) %>%
    dplyr::select(!where(is.list))
```

## Complm

Estimating bias  is complicated by the compositional nature of metabarcoding measurements. Because only relative abundances are measured, the measurement of a  sample (s) only provides information about the efficiencies of the taxa in the sample relative to each other.

Here we fit a simple linear model on the compositional difference between Observed and Expected counts. The compositional error vectors are first geometrically centered, then taxon is used as a predictor.

```{R compositional regressions}
fit_complm <- joint %>%
  filter(exp_individuals > 0) %>%
  group_by(mixture_type, target_subfragment)  %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, center_elts(observed0 / exp_individuals) ~ 0 + taxon, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    )

#results
complm_results <- fit_complm %>%
  unnest(pred, data) %>%
  dplyr::filter(exp_individuals > 0)%>% 
  mutate(
    predicted = exp_individuals * .pred, 
    estimated = .pred
  ) %>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
  dplyr::select(!where(is.list))

complm_results %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)
```

## metacal

Here we use the bias estimation approach of *McLaren, M. R., Willis, A. D., & Callahan, B. J. (2019). Consistent and correctable bias in metagenomic sequencing experiments. Elife, 8.* This approach treats the abundances and errors as compositional vectors and estimates the bias as the geometric center of these bias vectors. 

This is a compositionally appropriate alternative to taking the arithmetic mean of errors in proportions as above.

```{R metacal}
fit_metacal <- joint %>%
   group_by(target_subfragment, mixture_type) %>%
    nest() %>%
    mutate(
        fit = purrr::map(data, function(x){
        err_mat <- x %>%
          dplyr::select(sample_id, taxon, err_individuals)%>%
          pivot_wider(id_cols= sample_id,
                      names_from = "taxon",
                      values_from = "err_individuals",
                      values_fill = list(err_individuals=NaN))%>%    
          column_to_rownames("sample_id") %>%
          as.matrix() 
        rows_to_keep <- rowSums(err_mat, na.rm=TRUE) > 0
        cols_to_keep <- colSums(err_mat, na.rm=TRUE) > 0
        err_mat <- err_mat[rows_to_keep, cols_to_keep]
        metacal::center(err_mat, method="proj", enframe=TRUE) %>%
        magrittr::set_colnames(c("taxon", ".pred"))
        })) %>%
    unnest(fit) 

#results
metacal_results <- joint %>%
  left_join(fit_metacal) %>%
  dplyr::filter(exp_individuals> 0) %>% 
  mutate(
    predicted = exp_individuals * .pred,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
  dplyr::select(!where(is.list))

metacal_results %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted)
```

# Evaluate model fits

Here we compare the accuracy of the bias estimation procedure by looking at the Root Mean Square Error (RMSE) between the observed relative abundances from sequencing, and the predicted relative abundances (Expected * Bias estimate) from each model.

To determine the models predictive ability to new data, we also determine these metrics for a seperate testing set of samples that the model was not trained on.

```{R model comparison}
all_fits <- do.call("list", mget(grep("_results",names(.GlobalEnv),value=TRUE))) %>%
  bind_rows(.id="model") 

fits <- all_fits %>%
  mutate(model = model %>%
           str_remove("_results")) %>%
  dplyr::select(model, taxon, mixture_type, target_subfragment, sample_id, run, exp_individuals, observed, predicted, estimated) 

# Plot bias estimates
gg.bias_ests <- fits %>%
  ggplot(aes(taxon, y=estimated-1, fill=model, group=model)) +
    geom_col(position=position_dodge(width=0.9))+
    facet_grid(target_subfragment~mixture_type, scales="free") +
  coord_flip() +
  scale_fill_brewer(palette="Paired") +
  labs(
    x = "Taxon",
    y = "Bias estimate",
    fill="Model")

gg.bias_ests

#Save figure
pdf(file="figs/model_comparisons/bias_estimates.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.bias_ests)
try(dev.off(), silent=TRUE)
```

## How well do the bias models explain the data?

```{r model fits}
# Visualise fits to data
gg.bias_preds <- fits %>%
  ggplot(aes(logit(predicted), logit(observed), color = taxon, shape=target_subfragment)) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_point(alpha = 0.5) +
  coord_fixed() + 
  facet_grid(mixture_type~model) +
  scale_color_manual(values = colours.taxon) +
  theme(legend.position = "bottom")+
    labs(x = "log-odds(Predicted proportion)", 
        y = "log-odds(Observed proportion)",
        colour = "Taxon",
        shape = "Primer pair",
        title="Bias model fits") 

gg.bias_preds

#Save figure
pdf(file="figs/model_comparisons/bias_preds.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.bias_preds)
try(dev.off(), silent=TRUE)

# Get RMSE
error <- fits %>%
  group_by(model, target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) #could also do somethign  else here

# plot rmse
gg.rmse <- error %>%
  filter(!model %in% c("fra", "fra2")) %>%
  ggplot(aes(x=model, y=.estimate, fill=model)) +
  geom_col() +
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle=45, hjust = 1)) +
  labs(x = "Model",
       y = "RMSE")+
  theme(axis.text.x = element_text(angle=45, hjust = 1))

gg.rmse

#Save figure
pdf(file="figs/model_comparisons/rmse.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.rmse)
try(dev.off(), silent=TRUE)
```

## How well do the estimated bias recover the true composition

```{r calibration}
cal <- fits %>%
    ungroup() %>%
    dplyr::mutate(calibrated = observed / estimated) %>%
    group_by(sample_id, model) %>%
    mutate_at(vars(calibrated), ~ . / sum(., na.rm=TRUE) )  %>%
    ungroup() 


gg.cal <- ggplot(cal, aes(x=taxon, y= odds(calibrated) / odds(exp_individuals), shape=target_subfragment )) +
    geom_hline(yintercept=1, alpha=0.8)+
  geom_jitter(aes(x=taxon, y= odds(observed) / odds(exp_individuals)),
              colour="grey", alpha=0.7, width = 0.1, height = 0)+
    geom_jitter(aes(colour = taxon),alpha=0.7, width = 0.1, height = 0) +
    geom_rangeframe(color = "black") + 
    scale_y_log10() + 
    facet_grid(mixture_type ~ model) +
    labs(x = "Taxon", 
        y = "Odds calbirated / expected",
        colour = "Taxon",
        shape = "Primer pair") +
    coord_flip() +
  scale_color_manual(values = colours.taxon) + 
    theme(legend.position = "bottom")

gg.cal

#Save figure
pdf(file="figs/model_comparisons/calibration.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.cal)
try(dev.off(), silent=TRUE)

```

From the above we can see that the metacal and complm models fit the data the best. We will do the rest of the analysis with the complm as the regression framework provides more flexibility

# Fit final model 

We will use bootstrapping to get a best estimate and associated confidence intervals, which will take the form of geometric mean and standard deviations of the bootstrap estimates.

Tje geometric mean and the geometric standard deviation of a sample of data from a log-normally distributed population may be used to find the bounds of confidence intervals analogously to the way the arithmetic mean and standard deviation are used to bound confidence intervals for a normal distribution.

When using geometric SD factor in conjunction with geometric mean, it should be described as "the range from (the geometric mean divided by the geometric SD factor) to (the geometric mean multiplied by the geometric SD factor), and one cannot add/subtract "geometric SD factor" to/from geometric mean

Therefore the estimated efficiencies are shown as the best estimate multiplied and divided by two geometric standard errors

```{r Final model}
lm_dat <- joint %>%
  filter(exp_individuals > 0) %>%
  group_by(mixture_type, target_subfragment) 

group_name <- group_keys(lm_dat) %>%
  unite(col="name", everything(), sep=";") %>%
  pull(name)

lm_dat <- lm_dat %>%
  group_split() %>%
  set_names(group_name)

set.seed(606)
boots <- purrr::map(lm_dat, bootstraps, times=1000, apparant=TRUE)

# Fit model to bootstraps
boot_models <- boots %>% 
  purrr::map(function(x){ 
    x <- x %>%
      mutate(lm_obj = map(splits, ~lm(center_elts(observed0 / exp_individuals) ~ 0 + taxon, data = .)), #why cant i use lm spec here?
            pred = map2(lm_obj, splits, function(.model, .data) predict(.model, .data)),
            coef_info = map(lm_obj, tidy),
            aug = map(lm_obj, broom::augment),
            data = map(splits, function(y){
              as.data.frame(y) %>%
                dplyr::select(observed, count, mixture_type, sample_id, taxon, exp_individuals)})
        ) 
    }) 

# Get coefficients
boot_coefs <- boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(coef_info)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  mutate(taxon = str_remove(term, "taxon")) %>%
  mutate(extract_type = case_when(
      mixture_type=="DNEasy" ~ "DNEasy",
      mixture_type=="QuickExtract" ~ "QuickExtract",
      TRUE ~ "NA"
    ))%>%
    dplyr::select(!where(is.list))


# Final model fits

# How to get the original data from the bootstraps?

#results
boot_results <- boot_models%>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(pred, data)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  dplyr::filter(exp_individuals > 0)%>% 
  mutate(
    predicted = exp_individuals * pred, 
    estimated = pred
  ) %>%
  group_by(sample_id, id) %>%
  mutate_at(vars(predicted, observed, exp_individuals), ~ . / sum(., na.rm=TRUE) ) %>% #re-close elements
  dplyr::select(!where(is.list))

# Get RMSE
final_error <- boot_results %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) #could also do somethign  else here

# Visualise fits to data
gg.final_fits <- boot_results %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  ggplot(aes(logit(predicted), logit(observed))) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_text(data=final_error, aes(x=-9, y=0, label=paste0("RMSE: ",round(.estimate, 2))),check_overlap = TRUE, inherit.aes = FALSE)+
 stat_density_2d(geom = "polygon", aes(alpha = ..level.., fill = taxon))+
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(panel.grid = element_line(size = rel(1))) +
  scale_alpha_continuous(range=c(0.3, 0.9))+
  theme(panel.grid = element_blank(),
        legend.position = "none")+
    labs(x = "Bias model prediction (log-odds)", 
        y = "Observed proportions (log-odds)",
        colour = "Taxon")+
  coord_cartesian(xlim = c(-12,3), ylim = c( -12, 3))

## Visualise errors in proportions
prop_error <- joint %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = expected, estimate = observed) #could also do somethign  else here


gg.err_prop <- joint%>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>% 
  mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(exp_individuals,observed, color = taxon)) + 
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_text(data=prop_error, aes(x=-9, y=0, label=paste0("RMSE: ",round(.estimate, 2))),check_overlap = TRUE, inherit.aes = FALSE)+
  geom_point(alpha=0.5) +
  scale_colour_manual(values = colours.taxon) +
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Expected proportions (log-odds)", 
       y = "Observed proportions (log-odds)",
       colour = "Taxon")  +
  base_theme +
  theme(panel.grid = element_blank(),
        legend.position = "none") +
    facet_grid(target_subfragment~mixture_type) +
  coord_cartesian(xlim = c(-12,3), ylim = c( -12, 3))

colours.taxon2 <- colours.taxon
names(colours.taxon2) <- names(colours.taxon) %>% str_replace("_", " ")

gg.final_ests <- boot_coefs  %>%
    group_by(taxon, target_subfragment, mixture_type) %>%
    summarise(gm_quantiles(estimate, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(estimate, na.rm=TRUE),
              gm_se = metacal::gm_sd(estimate, na.rm = TRUE)) %>%
    ungroup %>%
    mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  mutate(taxon = taxon %>% str_replace("_", " ")) %>%
  ggplot(aes(x=taxon, y=gm_mean, colour=taxon))+
  geom_pointrange(aes(ymin = gm_mean / gm_se^2, ymax = gm_mean * gm_se^2),
        fatten = 3,
        position = position_dodge(width = 0.5)) +
    scale_colour_manual(values = colours.taxon2) +
    geom_hline(yintercept = 1, colour="grey80" )  +
    scale_y_log10() +
    geom_rangeframe(color = "black") +
  base_theme +
  theme(panel.grid = element_blank(), 
        legend.position = "none",
        axis.text.x = element_text(face="italic")) +
    facet_grid(target_subfragment~mixture_type) +
  labs(y = "Efficiency / geometric mean",
       x = "Taxon")


Fig1 <- gg.err_prop /  gg.final_fits / gg.final_ests  + plot_annotation(tag_levels = "A")  & theme(plot.margin =unit(c(0,0,0,0), "cm"))

Fig1

#Save figure
pdf(file="figs/fig1_bias.pdf", width = 8, height = 9 , paper="a4")
  plot(Fig1)
try(dev.off(), silent=TRUE)

```


# Bias partitioning

```{r Bias partition}
# Partition the bias in all bootstrap replicates
boot_partitioned <- boot_coefs %>%
  dplyr::filter(!extract_type=="NA") %>% 
  dplyr::select(target_subfragment,  extract_type, mixture_type,
                taxon, id, estimate) %>%
  left_join(boot_coefs %>%
  dplyr::filter(extract_type=="NA") %>%
  dplyr::select(taxon, target_subfragment, mixture_type,id, estimate) %>%
    distinct %>%
    pivot_wider(names_from = mixture_type,
              values_from=estimate)) %>%
  group_by(extract_type, target_subfragment, taxon) %>%
    transmute(bias_all = estimate,
              bias_extract = estimate / DNA,
              bias_PCR = DNA / PCR,
              bias_seq = PCR)

# Calculate bias as geometric mean, and standard error as geometric standard error of bootstrap replicates
bias_steps <- boot_partitioned %>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
    group_by(taxon, target_subfragment,extract_type, step) %>%
    summarise(gm_quantiles(bias, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(bias, na.rm=TRUE),
              gm_se = metacal::gm_sd(bias, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q"))

# Need to understand why we choose 2 geometric standard errors??
gg.bias_steps <- bias_steps %>%
  dplyr::filter(!(extract_type=="QuickExtract" & !step=="extract")) %>%
  ungroup() %>%
    mutate(extract_type = case_when(
      !step=="extract" ~ "NA",
      TRUE ~ extract_type
      )) %>%
  ggplot(aes(x=step, y=gm_mean, shape=extract_type, colour = taxon)) +
    geom_pointrange(aes(ymin = gm_mean / gm_se^2, ymax = gm_mean * gm_se^2), #This cant be right
        fatten = 4,
        position = position_dodge(width = 0.5)) +
    geom_hline(yintercept = 1, colour="grey80" )  +
    scale_y_log10() +
    geom_rangeframe(color = "black") +
    scale_colour_manual(values = colours.taxon) +
    scale_shape_manual(values = c(17,19,8))+ 
    facet_grid(target_subfragment~.)+
    labs(x = "Contribution of laboratory step",
         y = "Efficiency / geometric mean",
         colour = "Taxon",
         shape = "DNA Extraction") +
  base_theme+
  theme(legend.position = "bottom") 

gg.bias_steps

# Relative abundance trajectories through the workflow
ra_traj <- bias_steps %>%
    pivot_wider(names_from = step,
              values_from=starts_with("gm_")) %>%
  group_by(extract_type, target_subfragment) %>%
  transmute(taxon,
        RA_Insects = 1,
        SE_Insects = 1,
        RA_DNA = RA_Insects * gm_mean_extract, 
        SE_DNA = SE_Insects * gm_se_extract,
        RA_Amplicons = RA_DNA * gm_mean_PCR, 
        SE_Amplicons = SE_DNA * gm_se_PCR,
        RA_Libraries = RA_Amplicons * gm_mean_seq,
        SE_Libraries = SE_Amplicons * gm_se_seq
        ) %>%
  mutate(taxon = fct_reorder(taxon, RA_Libraries)) %>%
  pivot_longer(starts_with(c("RA_", "SE_")),
               names_to = c(".value", "position"),
               values_to = "abundance",
               names_pattern = "(..)(_.*$)"
               ) %>%
  mutate(position = position %>% str_remove("_") %>%
           factor(levels=c("Insects", "DNA", "Amplicons", "Libraries")))

# make plot
gg.ra_traj <- ra_traj %>%
    ggplot(aes(position, RA, color = taxon)) +
    geom_hline(yintercept = 1, colour="grey80")  +
    geom_path(aes(group = taxon)) +
    geom_point() +
    scale_y_log10() +
    geom_rangeframe(color = "black") +
    scale_color_manual(values = colours.taxon) +
  facet_grid(target_subfragment~extract_type)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "Relative abundance trajectories") + 
  theme(legend.position = "bottom")
  
gg.ra_traj

#Save figure
pdf(file="figs/ra_trajectories.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.ra_traj)
try(dev.off(), silent=TRUE)

## Plot the trajectories as small multiples with error pars

gg.ra_traj2 <- ra_traj %>%
  dplyr::filter(extract_type == "DNEasy") %>%
  dplyr::filter(!taxon == "Bradysia_nr.ocellaris") %>%
    ggplot(aes(x = position, y= RA, color = taxon, group=extract_type, shape=extract_type, fill=taxon)) +
    geom_hline(yintercept = 1, colour="black" )  +
    geom_line() +
    geom_text(aes(label=paste0("x",round(RA, 1))),nudge_y=2, colour="black")+
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10() +
    scale_color_manual(values = colours.taxon) +
    scale_fill_manual(values = colours.taxon) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "DNEasy")   +
  theme_void() +
  theme(panel.spacing = unit(0, "lines"),
        legend.position = "none",
        strip.text.y = element_blank())

gg.ra_traj2

gg.ra_traj3 <- ra_traj %>%
  dplyr::filter(extract_type == "QuickExtract") %>%
    ggplot(aes(x = position, y= RA, color = taxon, group=extract_type, shape=extract_type, fill=taxon)) +
    geom_hline(yintercept = 1, colour="black")  +
    geom_line() +
    geom_text(aes(label=paste0("x",round(RA, 1))),nudge_y=2, colour="black")+
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10() +
    scale_color_manual(values = colours.taxon) +
    scale_fill_manual(values = colours.taxon) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "QuickExtract") +
  theme_void() +
  theme(panel.spacing = unit(0, "lines"),
        panel.grid = element_blank(),
        legend.position = "none")
 

Fig1a <- gg.ra_traj2 + gg.ra_traj3 

Fig1 <- gg.bias_steps - Fig1a + plot_annotation(tag_levels = "A")

Fig1

# CAn i addd little +1 -0.4 icons to the plot tahat will allow me t oget rid of the left plot

#Save figure
pdf(file="figs/fig1_bias_partitioned.pdf", width = 11, height = 8 , paper="a4r")
  plot(Fig1)
try(dev.off(), silent=TRUE)

```

# Next - model partitioned bias as a function of species traits
: First,
how do the traits of the taxon (size, sclerotization) affect its probability of detection (presence/absence) in the two types of samples?
Second, how do the traits of the taxon affect its relative read count
in the two types of samples?
To answer the first question, we used a generalized linear
mixed effects model of presence as a function of fixed effects
Sample type (ethanol or tissue), size and sclerotization, along with
all two‐ and three‐way interactions. To account for the paired design (where both types of samples were derived from the same
Malaise trap catches), we defined Sample ID as a random effect.
Since the response was binomial, we assumed a logit‐link and binomially distributed error.

#

  + Can Extraction bias be predicted by scheletorization?
  + Can PCR bias be predicted by amplicon GC content, or primer binding mismatch?
  + Can library bias be predicted by PCR barcode?

# Predict bias from pcr mismatch and gc content

We focused on the log ratio between actual and observed 

formula R = log{(nO + 0.5)/(nA + 0.5)} 
where R is the response
where nA is the taxon‐ and sample‐specific read count (Observed compositions) from the
sequencing, and nA is the actual proportion of biomass for that taxon in the sample

```{R prediction on partitioned}
#Predict seperated bias 
error_preds <- joint %>%
  left_join(bias_steps 
            #%>%
              #mutate(step = case_when(
              #  extract_type == "DNEasy" & step == "extract" ~ "DNEasy",
              #  extract_type == "QuickExtract" & step == "extract" ~ "QuickExtract",
              #  TRUE ~ step
              #)) %>%
              #dplyr::filter(!(extract_type == "QuickExtract" & !step == "QuickExtract"))
              ) %>%
  filter(exp_individuals > 0, mixture_type %in% c("DNEasy", "QuickExtract")) %>%
  mutate(primerdist = Fdist  + Rdist) %>%
  dplyr::rename(bias = gm_mean)

# Specify LM Recipe and map
lm_mod <-
  linear_reg(mode = "regression") %>%
  set_engine("lm")

wf <-
  workflow() %>%
  add_model(lm_mod)

## big function of model fitting and predicting
bias_coeffs <- function(df, step="all") {

  print(step)
  if(step == "extract"){
    df <- df %>% dplyr::select(bias, exoskeleton, biomass_mm3)
  } else if (step == "PCR"){
    df <-  df %>% dplyr::select(bias, primerdist, `G|C`)
  } else if(step== "seq"){
    df <-  df %>% dplyr::select(bias, `G|C`)
  } else if (step=="all"){
    df <- df
  }
  print(df)
  #create recipe
  lm_rec <- df %>%
    recipe(bias ~ ., data=df) %>%
    step_zv(all_numeric(), -all_outcomes()) %>%
    step_normalize(all_numeric()) %>%
    step_corr(all_numeric(), -all_outcomes(), threshold = 0.9) %>%
    step_lincomb(all_numeric(), -all_outcomes()) %>%
    step_dummy(all_nominal(), one_hot=TRUE) 
    
  print(prep(lm_rec))
  #fit workflow
  fit_wf <-
    wf %>%
    add_recipe(lm_rec) %>%
    fit(data = df)
  
  #Get coefficients
  fit_wf %>%
    pull_workflow_fit()  %>% 
  tidy()
}



partition_fit <- error_preds %>%
  ungroup()%>%
  filter(target_subfragment=="fwhF2-fwhR2n") %>%
  mutate(primerdist = Fdist + Rdist) %>%
  dplyr::select(bias, exoskeleton, biomass_mm3, primerdist, `G|C`, step, mixture_type) %>%
  mutate(exoskeleton= case_when(
           exoskeleton == 1 ~ "soft",
           exoskeleton == 2 ~ "medium",
           exoskeleton == 3 ~ "hard"
         ))  %>%
    mutate(exoskeleton = factor(exoskeleton, levels=c( "soft", "hard", "medium") ))%>%
  group_by(step, mixture_type)  %>% 
  nest() %>%
  #mutate(coef_info =  map2(data, step, possibly(bias_coeffs, otherwise = NA))) %>%
  mutate(coef_info =  map(data, possibly(bias_coeffs, otherwise = NA))) %>%
  unnest(coef_info) %>%
  #unnest(vi) %>%
  dplyr::select(!where(is.list)) 

partition_fit %>%
  dplyr::mutate(term = str_replace(term, "(Intercept)", "exoskeleton_medium")) %>%
  drop_na() %>%
  ggplot(aes(x=term, y=estimate)) + 
  geom_pointrange(aes(ymax = estimate+std.error, ymin=estimate-std.error), size=1)+
  geom_hline(yintercept = 0)+
  facet_grid(mixture_type~step) +
  coord_flip()

# A better comparison might be te residuals explained by the partitioned vs unpartitioned bias. Or the variance explained by each coefficient?


# Interestingly some nonsensical values are significant for some steps - ie primerdist is significant for extract
# This could either be because of correlation/colinearity with a more important predictor, or show that bias has not been properly partitioned

#%>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

#Fit for seperate partitions
extract_fit <- error_preds %>%
  filter(step=="extract") %>%
  mutate(primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ 1 + exoskeleton + biomass_mm3 , data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)%>%
  #dplyr::select(!where(is.list))  %>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

## QUestion - what does surface mm2 represent?

# PCR fit
pcr_fit <- error_preds %>%
  filter(step=="PCR") %>%
  mutate(primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ 1 + primerdist  + `G|C` , data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)%>%
  #dplyr::select(!where(is.list))  %>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

# sequencing fit
seq_fit <- error_preds %>%
  filter(step=="seq") %>%
  mutate(primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ 1 + primerdist  + `G|C` , data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)%>%
  #dplyr::select(!where(is.list))  %>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

```


# Plot trait correlations
```{r trait cor}

joint %>%
    dplyr::select(dorsal_area_mm2, depth_mm,lateral_area_mm2, surface_mm2, biomass_mm3, exoskeleton, Fdist, Rdist, `G|C`) %>%
    cor %>%
    {.[order(abs(.[, 1]), decreasing = TRUE), 
       order(abs(.[, 1]), decreasing = TRUE)]} %>%
    corrplot(method = "number", type = "upper", mar = c(0, 0, 1.5, 0),
            title = "Correlations between taxon traits")

```


### TRY WITH FULL MDOEL!

Doesnt work because of colienarity - ie these other factors are a function of taxon and therefore totally colinear
```{r}
# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm") %>%
  step_normalize(all_numeric()) %>%
  step_dummy(taxon, exoskeleton) 
lm_spec

fit_complm <- joint %>%
  filter(exp_individuals > 0) %>%
  mutate(#Fdist = replace_na(Fdist, 0), #NAs are actual missing data
         #Rdist = replace_na(Rdist, 0),
         primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  group_by(mixture_type, target_subfragment)  %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, center_elts(observed0 / exp_individuals) ~ exoskeleton + biomass_mm3 + primerdist + `G|C`, data = .)),
           #pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )

test <-fit_complm %>%
  unnest(coef_info)%>%
    dplyr::select(!where(is.list))
  
  
  boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(vi)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";")%>%
    dplyr::select(!where(is.list))



```



```{r bias preiction}
# Predict bias of the whole communties
bias <- boot_coefs  %>%
    dplyr::filter(!extract_type=="NA") %>%
    group_by(taxon, target_subfragment, extract_type) %>%
    summarise(gm_quantiles(estimate, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(estimate, na.rm=TRUE),
              gm_se = metacal::gm_sd(estimate, na.rm = TRUE)) %>%
    ungroup 

%>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
    group_by(taxon, target_subfragment,extract_type, step) %>%
    summarise(gm_quantiles(bias, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(bias, na.rm=TRUE),
              gm_se = metacal::gm_sd(bias, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q"))

#Predict on whole insect pools - want to rpedict the different bias
traits <- joint %>%
  left_join(bias) %>%
  filter(exp_individuals > 0, mixture_type %in% c("DNEasy", "QuickExtract")) %>%
  mutate(primerdist = Fdist  + Rdist)

```



# PCA plot of whole composition through process

Recreate process

See CJ batteys spacetree plot for how to plot this: https://github.com/cjbattey/spacetree/blob/master/spacetree.R

```{r}
test <- joint %>%
  dplyr::select(sample_id, taxon, exp_individuals, target_subfragment) %>%
  distinct() %>%
  left_join(bias_steps %>%
    pivot_wider(names_from = step,
              values_from=starts_with("gm"))) %>%
  group_by(extract_type, target_subfragment, sample_id) %>%
  mutate(
        T_Insects = exp_individuals,
        T_DNA = T_Insects * gm_mean_extract, 
        T_Amplicons = T_DNA * gm_mean_PCR, 
        T_Libraries = T_Amplicons * gm_mean_seq,
        ) %>%
  dplyr::select(-starts_with("gm_"), -exp_individuals) %>%
  mutate(taxon = fct_reorder(taxon, T_Libraries)) %>%
  pivot_longer(starts_with("T_"),
               names_to = "position",
               values_to = "abundance"
               ) %>%
  mutate(position = position %>% str_remove("T_") %>%
           factor(levels=c("Insects", "DNA", "Amplicons", "Libraries"))) %>%
  mutate(abundance = clr(abundance))

#PCA
test2 <- test %>% 
  ungroup %>%
  pivot_wider(names_from = taxon,
              values_from = abundance,
              values_fill = list(abundance=0)) 


pca_rec <- recipe(~., data = test2) %>%
  update_role(extract_type, target_subfragment, position, sample_id, new_role = "id") %>%
  step_normalize(all_predictors()) %>%
  step_pca(all_predictors())

pca_prep <- prep(pca_rec)

pca_prep

#Look at contributions to components
tidied_pca <- tidy(pca_prep,2) # 1 is for  step 1

tidied_pca %>%
  filter(component %in% paste0("PC", 1:5)) %>%
  mutate(component = fct_inorder(component)) %>%
  ggplot(aes(value, terms, fill = terms)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~component, nrow = 1) +
  labs(y = NULL) 

# Plot PCA
juice(pca_prep) %>%
  ggplot(aes(PC1, PC2, label = sample_id)) +
  geom_point(aes(color = sample_id), alpha = 0.7, size = 2) +
  geom_text(check_overlap = TRUE, hjust = "inward", family = "IBMPlexSans") +
  facet_grid(~position) %>%
  labs(color = NULL)

# 3d PCA

library(scatterplot3d)

test3 <- juice(pca_prep) %>%
  mutate(timepoint = case_when(
    position=="Insects" ~ 1,
    position=="DNA" ~ 2,
    position=="Amplicons" ~ 3,
    position=="Libraries" ~ 4
  )) %>%
  mutate(timepoint = as.factor(timepoint)) %>%
  dplyr::select(-PC3, -PC4, -PC5)

colors <- unname( colours.taxon[6:9])
colors <- colors[as.numeric(test3$timepoint)]
scatterplot3d(test3[,c(7,5,6)], grid=TRUE,pch=20, box=TRUE, color = colors )
```


# Reproducability Receipt

```{details, echo = FALSE, details.summary = 'Reproducability receipt'}
# datetime
Sys.time()

#repository
git2r::repository()

sessioninfo::session_info()
```