---
title: "Bias Partion Manuscript"
subtitle: "Statistical analysis"
author: "A.M. Piper"
date: "`r Sys.Date()`"
output: 
  html_document:
    highlighter: null
    theme: "flatly"
    code_download: true
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    df_print: paged    
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

# Introduction

* Comparisons of models
* Bias prediction using cofactors
  + Once bias has been partitioned to its relevant stage, we can accurately predict things
  + Can Extraction bias be predicted by scheletorization?
  + Can PCR bias be predicted by amplicon GC content, or primer binding mismatch?
  + Can library bias be predicted by PCR barcode?
  

Extra comparisons:
* Modelling of bias from # individuals vs biomass
* Modelling of contribution on partitioned vs non-partitioned bias
  + This would allow making a point that you need to partition biases to accurately improve protocols 


## Load packages
```{r load packages}
#Set required packages
.cran_packages <- c("tidyverse",
                    "tidymodels",
                    "janitor",
                    "vip",
                    "patchwork", 
                    "vegan", 
                    "seqinr",
                    "ape", 
                    "RColorBrewer",
                    "devtools",
                    "ggthemes",
                    "phangorn",
                    "ape",
                    "ggtree",
                    "ggcorrplot")
.bioc_packages <- c("dada2",
                    "phyloseq", 
                    "DECIPHER",
                    "Biostrings",
                    "ShortRead", 
                    "ALDEx2")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("mikemc/metacal")
devtools::install_github("alexpiper/taxreturn")
devtools::install_github("r-lib/conflicted")
devtools::install_github("easystats/report")

library(metacal)
library(taxreturn)
library(report)

#Source helper functions
source("R/helper_functions.R")
```

# Set a colour scheme & Define theme

```{r pick colours}
colours.taxon <- c(
  "Acizzia_alternata" = "#A6CEE3",
  "Acizzia_solanicola" = "#438FC0",
  "Aphidius_colemani" = "#808080",
  "Bactrocera_tryoni" = "#000000",
  "Bradysia_nr.ocellaris" = "#FFFF00",
  "Carpophilus_davidsoni" = "#9AD378",
  "Carpophilus_nr.dimidiatus" = "#3EA534",
  "Diuraphis_noxia" = "#B29C71",
  "Drosophila_hydei" = "#F26B6B"  ,
  "Drosophila_melanogaster" = "#E52823",
  "Drosophila_simulans" = "#FE9C32",
  "Lysiphlebus_testaceipes" = "#F08C3A",
  "Metopolophium_dirhodum" = "#CAB2D6",
  "Psyllid_sp" = "#000080",
  "Rhopalosiphum_padi" = "#FF00FF",
  "Scaptodrosophila_lativittata" = "#800080"
) 


#Source themes
source('R/themes.R')
```

# Read in data & get summary statistics

```{R read in}
counts <- read_csv("R_analysis/FILE_for_R_NEW.csv") %>%
  janitor::clean_names() %>%
  dplyr::mutate(sample_id = paste0(sample, "_", run),
                mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  TRUE ~ mixture_type
                  ),
                target_subfragment = case_when(
                  str_detect(sample, "P1$") ~ "fwhF2-fwhR2n",
                  str_detect(sample, "P2$") ~ "fwhF2-HexCOIR4",
                )) %>% 
  mutate(taxon = taxon %>% 
            str_replace("_dimidiatus", "_nr.dimidiatus") %>%
            str_replace("hydeii", "hydei") %>%
            str_replace("Bradysia_ocellaris", "Bradysia_nr.ocellaris")) %>%
  dplyr::select(-table) 


# new counts
ps <- readRDS("output/rds/ps.rds")

# Spread of reads between protocols
pre_filt <- speedyseq::psmelt(ps) %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(OTU, taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers, extraction_method) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  ))  %>%
  filter(Abundance > 0, !is.na(mixture_type))


# Total reads per FCID
pre_filt %>%
  group_by(fcid) %>%
  summarise(sum = sum(Abundance))

# Total ASVs
pre_filt %>%
  summarise(ASVs = n_distinct(OTU))

# Spread of Reads pre filtering
pre_filt %>%
  group_by(sample_id) %>%
  summarise(Abundance = sum(Abundance), fcid)%>%
  ungroup() %>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance))

# Spread of OTUS pre filtering
pre_filt %>%
  group_by(sample_id) %>%
  summarise(Abundance =  n_distinct(OTU), fcid)%>%
  ungroup() %>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance))

# Anova and pairwise comparisons of ASVs

# Rarefy to even depths
ps_rare <- rarefy_even_depth(ps, sample.size = min(100000),
  rngseed = 666, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)

rarestats <- speedyseq::psmelt(ps) %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(OTU, taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers, extraction_method) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  ))  %>%
  filter(Abundance > 0, !is.na(mixture_type))

asv_rare_pre <- rarestats %>%
  dplyr::filter(Abundance > 0) %>%
  group_by(sample_id, mixture_type, fcid) %>%
  summarise(counts = n_distinct(OTU)) %>%
  ungroup() 

asv_rare_pre %>%
  group_by(mixture_type)%>%
  summarise(mean = mean(counts), 
            se = sd(counts)/sqrt(length(counts)),
            max = max(counts),
            min = min(counts))

#ANOVA
report(aov(counts ~mixture_type, data=asv_rare_pre))
broom::tidy(TukeyHSD(aov(counts ~mixture_type, data=asv_rare_pre))) 

# Remove run 2 quickextract
rarestats2 <- speedyseq::psmelt(ps) %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(OTU, taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers, extraction_method) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  ))  %>%
  filter(Abundance > 0, !is.na(mixture_type)) %>%
  dplyr::filter(!(mixture_type=="QuickExtract" & fcid=="CJL7D")) 

# Prefilt
asv_rare_pre2 <- rarestats2 %>%
  dplyr::filter(Abundance > 0) %>%
  group_by(sample_id, mixture_type, fcid, target_subfragment) %>%
  summarise(counts = n_distinct(OTU)) %>%
  ungroup() 

asv_rare_pre2 %>%
  group_by(mixture_type)%>%
  summarise(mean = mean(counts), 
            se = sd(counts)/sqrt(length(counts)),
            max = max(counts),
            min = min(counts))

#ANOVA

#Mixture type
report(aov(counts ~mixture_type, data=asv_rare_pre2))
broom::tidy(TukeyHSD(aov(counts ~mixture_type, data=asv_rare_pre2))) 

#Primers
report(aov(counts ~target_subfragment, data=asv_rare_pre2))
broom::tidy(TukeyHSD(aov(counts ~target_subfragment, data=asv_rare_pre2))) 

# Post filt
asv_rare_post <- rarestats2 %>%
  filter(!is.na(taxon)) %>%
  dplyr::filter(Abundance > 0) %>%
  group_by(sample_id, mixture_type, fcid, target_subfragment) %>%
  summarise(counts = n_distinct(OTU)) %>%
  ungroup() 

asv_rare_post %>%
  group_by(mixture_type)%>%
  summarise(mean = mean(counts), 
            se = sd(counts)/sqrt(length(counts)),
            max = max(counts),
            min = min(counts))

#ANOVA

# Mixture type
report(aov(counts ~mixture_type, data=asv_rare_post))
broom::tidy(TukeyHSD(aov(counts ~mixture_type, data=asv_rare_post))) 

#Primers
report(aov(counts ~target_subfragment, data=asv_rare_post))
broom::tidy(TukeyHSD(aov(counts ~target_subfragment, data=asv_rare_post))) 

#Where is hte higher quickextract coming from
haplotypes <- rarestats2 %>%
  filter(!is.na(taxon)) %>%
  group_by(mixture_type, target_subfragment, taxon) %>%
  summarise(haplo = n_distinct(OTU)) %>%
  pivot_wider(names_from = mixture_type, values_from=haplo)


# Compare primers


# Filter out unclassified and agglomerate species
ps0 <- ps %>%
  subset_taxa(
    phylum == "Arthropoda"
  ) %>%
  filter_taxa(function(x) mean(x) > 0, TRUE) %>%
  prune_samples(sample_sums(.) >0, .) %>%
  tax_glom("species")

saveRDS(ps0, "output/rds/ps_filtered.rds")

newcounts <- ps0 %>%
  speedyseq::psmelt() %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(taxon, sample_id, Abundance, sample, fcid) %>%
  filter(Abundance > 0, !is.na(taxon)) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ))

combined_analysis <- counts %>% left_join(newcounts) %>%
  group_by(sample_id) %>%
  filter(!is.na(fcid)) %>%
  mutate(prop = Abundance) %>%
  mutate_at(c("prop"),  ~ . / sum(., na.rm = TRUE) )

# Check consistency between analyses
gg.combined_analyses <- combined_analysis %>% 
  dplyr::select(sample_id, taxon, prop, observed, fcid) %>%
  mutate(observed = observed / 100) %>%
  dplyr::rename(analysis1 = observed, analysis2 = prop) %>%
  pivot_longer(starts_with("analysis"),
               names_to="analysis",
               values_to="Abundance") %>%
  ggplot(aes(x = sample_id, y=Abundance, fill=taxon))+
  geom_col(position="stack") +
  facet_grid(analysis~fcid, scales="free", drop=TRUE) +
  scale_fill_manual(values=colours.taxon)+ 
  #scale_fill_brewer(palette="Paired") +
  base_theme +
  labs(x = "Sample", y="Relative Abundance", fill="Taxon")

gg.combined_analyses


# Replace old analysis with new
counts <- combined_analysis %>%
  dplyr::select(-observed, -count) %>%
  dplyr::rename(observed = prop, count = Abundance) %>%
  dplyr::mutate(observed = replace_na(observed, 0),
                count = replace_na(count, 0))

# Check all are proportions  
counts %>%
  group_by(sample, run) %>%
  summarise(exp = sum(expected), obs = sum(observed), count = sum(count))

# N unique species and samples
 counts %>%
  summarise(n_samples = n_distinct(sample), n_sequenced_samples = n_distinct(sample_id))

# Spread of reads
counts %>%
  group_by(sample_id) %>%
  summarise(exp_prop = sum(expected), obs_prop = sum(observed), Abundance = sum(count), run) %>%
  ungroup() %>%
  #group_by(run)%>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance),
            exp_prop = mean(exp_prop),
            obs_prop = mean(obs_prop))

```

## Add species traits

```{r biomass transform}
traits <- readxl::read_excel("biomass and hardness.xlsx")  %>%
  janitor::clean_names() %>%
  dplyr::rename(taxon = species) %>%
  filter(!is.na(taxon)) %>%
  dplyr::mutate(taxon = taxon %>%
                  str_replace("C\\.", "Carpophilus") %>%
                  str_replace("D\\.", "Drosophila") %>%
                  str_replace("A\\.", "Acizzia") %>%
                  str_replace("hydeii", "hydei") %>%
                  str_replace_all(" ", "_") %>%
                  str_remove_all("\\.")%>%
                  str_replace("nr_dimidiatis", "nr.dimidiatus")%>%
                  str_replace("Bradysia_ocellaris", "Bradysia_nr.ocellaris")

                  ) %>%
  dplyr::mutate(exoskeleton = as.numeric(exoskeleton))

# Plot measured traits
traits %>%
  pivot_longer(-c("taxon", "order"), 
               names_to = "trait",
               values_to = "value") %>%
  ggplot(aes(x=taxon, y=value, fill=order)) + 
  geom_col() +
  facet_grid(~trait) + 
  coord_flip() +
  scale_fill_brewer(palette="Paired")

#Check for differencess in taxon names
setdiff(traits$taxon, counts$taxon)
setdiff(counts$taxon, traits$taxon)

# Join tables together
joint <- counts %>%
  left_join(traits%>%
            mutate(taxon = taxon %>% str_replace("hydeii", "hydei")), by="taxon") %>%
  dplyr::mutate(exp_individuals = expected,
                exp_individuals = expected * biomass_mm3) %>%
  group_by(sample_id) %>%
    mutate_at(vars(exp_individuals, exp_individuals, observed), ~ . / sum(.) ) %>% #Convert back to proportions
  ungroup() %>%
  mutate(observed0 = (count + 0.5) * (expected > 0)) %>% #Add a pseudocount
  mutate(err_biomass = observed0 / exp_individuals,
         err_individuals = observed0 / exp_individuals) %>%
  ungroup() 

# Check if any werent properly joined
table(is.na(joint$exp_individuals))

# Plot expected individuals vs expected biomass
gg.p1 <- joint %>%
  dplyr::filter(target_subfragment=="fwhF2-fwhR2n") %>% #Filter to primer1
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - fwhR2n")

gg.p2 <- joint %>%
  dplyr::filter(target_subfragment =="fwhF2-HexCOIR4") %>% 
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - HexCOIR4")

gg.p1 + gg.p2
```

## Add sequence traits

```{r sequence traits}
# Get PHMM of full folmer region
coi_model <- readRDS("reference/folmer_fullength_model.rds")

primers <- tribble(
  ~Fname, ~Fprimer, ~Rname, ~Rprimer,
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "fwhR2n","GTRATWGCHCCDGCTARWACWGG",
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "HexCOIR4", "TATDGTRATDGCHCCNGC", 
  ) %>%
    left_join(.$Fprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, minscore=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("F",.)), by="Fprimer") %>%
    left_join(.$Rprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, minscore=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("R",.)), by="Rprimer")

# Read in sequences
seqs <- insect::readFASTA("reference/mock_spp2.fa")

# Add primers to seqs
primers.dna <- insect::char2dna(c("GGDACWGGWTGAACWGTWTAYCCHCC", rc("GTRATWGCHCCDGCTARWACWGG"),rc("TATDGTRATDGCHCCNGC")))
names(primers.dna) <- c("fwhF2", "fwhR2n", "HexCOIR4")

#Join to seqs
seqs <- c(seqs, primers.dna)

# Trim seqs to Fprimer bind region and get primer edit distance
aligned <- taxreturn::map_to_model(seqs, coi_model, minscore = 0, shave= TRUE, pad=TRUE, check_indels=FALSE, maxNs=Inf, cores=1, quiet=FALSE)

#Transform to DNAstringSet
aligned <- aligned %>% as.list %>% as.character %>% lapply(., paste0, collapse = "") %>% 
            unlist %>% DNAStringSet

# Check alignment
#BrowseSeqs(aligned)

#Get forward dist
Fprimerdist <- Biostrings::subseq(aligned, start=primers$Fstart[1], end = primers$Fend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Fprimer") %>%
  pivot_longer(cols=-Fprimer,
               names_to="taxon",
               values_to="Fdist") %>%
  filter(Fprimer=="fwhF2", !taxon %in% names(primers.dna)) %>%
  filter(Fdist < 0.5) #Filter bad alignments

#Get reverse dist
Rprimerdist <- bind_rows(
  #Rprimer1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[1]],
                     start=primers$Rstart[1], end = primers$Rend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="fwhR2n", !taxon %in% names(primers.dna)),
  #Rprimer2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[2]],
                   start=primers$Rstart[2], end = primers$Rend[2]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="HexCOIR4", !taxon %in% names(primers.dna))
)%>%
  filter(Rdist < 0.5) #Filter bad alignments

# get amplicon gc content
primergc <- bind_rows(
  #primer set 1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[1]],
                     start=primers$Fend[1]+1, end = primers$Rstart[1])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[1]]),
         target_subfragment = paste0(primers$Fname[1], "-", primers$Rname[1])) %>%
  dplyr::filter(!taxon %in% names(primers.dna)),
  #primer set 2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[2]],
                   start=primers$Fend[2]+1, end = primers$Rstart[2])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[2]]),
         target_subfragment = paste0(primers$Fname[2], "-", primers$Rname[2])) %>%
  dplyr::filter(!taxon %in% names(primers.dna))
)

joint <- joint %>%
  separate(target_subfragment, into=c("Fprimer", "Rprimer"), sep="-", remove=FALSE) %>%
  left_join(Fprimerdist) %>%
  left_join(Rprimerdist) %>%
  left_join(primergc) 

```

## Create phylogeny
```{r phylogeny}
tree_alignment <- aligned[names(aligned) %in% joint$taxon]

phang.align <- phyDat(as(tree_alignment, "matrix"), type="DNA")

dm <- dist.ml(phang.align)

#Fit NJ tree
treeNJ <- NJ(dm) # Note, tip order != sequence order
fit <- pml(treeNJ, data=phang.align)

#Fit ML tree
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
                      rearrangement = "stochastic", control = pml.control(trace = 0))

tree <- fitGTR$tree

ggtree(tree) + geom_tiplab()

#Output newick tree
write.tree(tree, file="output/tree.nwk")
```



## Look at differences between runs

```{r run differences}
# Plot differences in quickextract - non-quickextract between runs
gg.runra <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
    ggplot(aes(x=sample, y=value, fill=taxon)) +
    geom_col(position="stack") +
    facet_grid(run~mixture_type, scales="free") +
    scale_fill_manual(values = colours.taxon) +
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_y_continuous(labels = scales::percent) +
    labs(x="Sample", y="Relative abundance")

# Plot as heatmap
gg.runhmap <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
  mutate(value = na_if(value, 0)) %>%
    ggplot(aes(x=sample, y=taxon, fill=value)) +
    geom_tile() +
    facet_grid(run~mixture_type, scales="free") +
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_fill_viridis_c(labels = scales::percent) +
    labs(x="Sample",
         y="Taxon",
         fill="Relative abundance")

gg.runcomparison <- gg.runra - gg.runhmap + plot_annotation(tag_levels="A")

gg.runcomparison

#Write out
pdf(file="figs/supplementary/run_comparison.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.runcomparison)
try(dev.off(), silent=TRUE)
  
# Remove the quickextract samples from run 2
joint <- joint %>%
  dplyr::filter(!(mixture_type=="QuickExtract" & run==2))
```

DNApools and PCR pools 1-4 and 5-8 arent exact replicates because of the extra species that were found

## Visualise bias

```{r visualise bias}
## Visualise errors in proportions
gg.err_prop <- joint %>% 
  mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(observed, exp_individuals, color = taxon)) + 
  geom_jitter(alpha=0.7) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  scale_colour_manual(values = colours.taxon) +
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Observed proportions (log-odds)", 
       y= "Expected proportions (log-odds)",
       colour = "Taxon") 

gg.err_prop

#Write out
pdf(file="figs/supplementary/err_proportions.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_prop)
try(dev.off(), silent=TRUE)

# Visualise the error in all pairwise ratios
  
err_ratio <- joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  #filter(!taxon=="Bradysia_nr.ocellaris") %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  mutate(Pair = paste(Taxon.x, Taxon.y, sep = ":"))

# Mean error ratios
err_ratio %>% 
  group_by(mixture_type, target_subfragment) %>%
  summarise(mpr = mean(err_individuals, na.rm=TRUE))

gg.err_ratio <- err_ratio %>% 
  ggplot(aes(Pair, err_individuals, colour=sample_id)) +
  geom_jitter(alpha=0.7) +
  geom_hline(yintercept = 1) +
  scale_y_log10() +
  facet_grid(target_subfragment~mixture_type)+
    theme(legend.position = "none",
          axis.text.x = element_text(angle=45, hjust=1))+
  labs(y= "Error in taxon ratios (log10)") 

gg.err_ratio

#Save figure
pdf(file="figs/supplementary/err_ratio.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_ratio)
try(dev.off(), silent=TRUE)
  
# Get the average pairwise bias for each method
joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  group_by(mixture_type, target_subfragment) %>%
  summarise(mean = mean(err_individuals, na.rm=TRUE), sd = sd(err_individuals, na.rm=TRUE), lower = range(err_individuals, na.rm = TRUE)[1], upper = range(err_individuals, na.rm = TRUE)[2])
```


# Compare bias models

We will now estimate the bias using different conventional and CODA models

## Mean proportions

Here we estimate bias as the arithmetic mean of the error in proportions

```{r mean proportions}
# Compare these fits!  
fit_prop <- joint %>%
  filter(expected > 0) %>%
  mutate(error = observed / exp_individuals) %>%
  group_by(mixture_type, target_subfragment, taxon) %>%
  summarise(.pred = mean(error))

#results
prop_results <- joint %>%
  dplyr::filter(expected > 0) %>%
  left_join(fit_prop) %>%
  mutate(
    predicted =  exp_individuals * .pred, 
    observed = observed,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
```

## simple lm

Here we estimate bias using a simple linear regression model of the expected and observerd proportions. The model is fit seperately to each taxon and material type.


```{r simple lm}
# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm")
lm_spec

fit_lm <- joint %>%
  filter(expected > 0) %>%
  group_by(taxon, target_subfragment, mixture_type) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, observed ~ 0 + exp_individuals, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    ) %>%
  unnest(coef_info)

#results
lm_results <- fit_lm %>%
  unnest(pred, data) %>%
  mutate(
    predicted = .pred
  ) %>%
    dplyr::select(!where(is.list))
```

## Complm

Estimating bias  is complicated by the compositional nature of metabarcoding measurements. Because only relative abundances are measured, the measurement of a  sample (s) only provides information about the efficiencies of the taxa in the sample relative to each other.

Here we fit a simple linear model on the compositional difference between Observed and Expected counts. The compositional error vectors are first geometrically centered, then taxon is used as a predictor.

```{R compositional regressions}
fit_complm <- joint %>%
  filter(exp_individuals > 0) %>%
  group_by(mixture_type, target_subfragment)  %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, center_elts(observed0 / exp_individuals) ~ 0 + taxon, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    )

#results
complm_results <- fit_complm %>%
  unnest(pred, data) %>%
  dplyr::filter(exp_individuals > 0)%>% 
  mutate(
    predicted = exp_individuals * .pred, 
    estimated = .pred
  ) %>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
  dplyr::select(!where(is.list))

complm_results %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)
```

## metacal

Here we use the bias estimation approach of *McLaren, M. R., Willis, A. D., & Callahan, B. J. (2019). Consistent and correctable bias in metagenomic sequencing experiments. Elife, 8.* This approach treats the abundances and errors as compositional vectors and estimates the bias as the geometric center of these bias vectors. 

This is a compositionally appropriate alternative to taking the arithmetic mean of errors in proportions as above.

```{R metacal}
fit_metacal <- joint %>%
   group_by(target_subfragment, mixture_type) %>%
    nest() %>%
    mutate(
        fit = purrr::map(data, function(x){
        err_mat <- x %>%
          dplyr::select(sample_id, taxon, err_individuals)%>%
          pivot_wider(id_cols= sample_id,
                      names_from = "taxon",
                      values_from = "err_individuals",
                      values_fill = list(err_individuals=NaN))%>%    
          column_to_rownames("sample_id") %>%
          as.matrix() 
        rows_to_keep <- rowSums(err_mat, na.rm=TRUE) > 0
        cols_to_keep <- colSums(err_mat, na.rm=TRUE) > 0
        err_mat <- err_mat[rows_to_keep, cols_to_keep]
        metacal::center(err_mat, method="proj", enframe=TRUE) %>%
        magrittr::set_colnames(c("taxon", ".pred"))
        })) %>%
    unnest(fit) 

#results
metacal_results <- joint %>%
  left_join(fit_metacal) %>%
  dplyr::filter(exp_individuals> 0) %>% 
  mutate(
    predicted = exp_individuals * .pred,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
  dplyr::select(!where(is.list))

metacal_results %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted)
```

# Evaluate model fits

Here we compare the accuracy of the bias estimation procedure by looking at the Root Mean Square Error (RMSE) between the observed relative abundances from sequencing, and the predicted relative abundances (Expected * Bias estimate) from each model.

To determine the models predictive ability to new data, we also determine these metrics for a seperate testing set of samples that the model was not trained on.

```{R model comparison}
all_fits <- do.call("list", mget(grep("_results",names(.GlobalEnv),value=TRUE))) %>%
  bind_rows(.id="model") 

fits <- all_fits %>%
  mutate(model = model %>%
           str_remove("_results")) %>%
  dplyr::select(model, taxon, mixture_type, target_subfragment, sample_id, run, exp_individuals, observed, predicted, estimated) 

# Plot bias estimates
gg.bias_ests <- fits %>%
  ggplot(aes(taxon, y=estimated-1, fill=model, group=model)) +
    geom_col(position=position_dodge(width=0.9))+
    facet_grid(target_subfragment~mixture_type, scales="free") +
  coord_flip() +
  scale_fill_brewer(palette="Paired") +
  labs(
    x = "Taxon",
    y = "Bias estimate",
    fill="Model")

gg.bias_ests

#Save figure
pdf(file="figs/model_comparisons/bias_estimates.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.bias_ests)
try(dev.off(), silent=TRUE)
```

## How well do the bias models explain the data?

```{r model fits}
# Visualise fits to data
gg.bias_preds <- fits %>%
  ggplot(aes(logit(predicted), logit(observed), color = taxon, shape=target_subfragment)) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_point(alpha = 0.5) +
  coord_fixed() + 
  facet_grid(mixture_type~model) +
  scale_color_manual(values = colours.taxon) +
  theme(legend.position = "bottom")+
    labs(x = "log-odds(Predicted proportion)", 
        y = "log-odds(Observed proportion)",
        colour = "Taxon",
        shape = "Primer pair",
        title="Bias model fits") 

gg.bias_preds

#Save figure
pdf(file="figs/model_comparisons/bias_preds.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.bias_preds)
try(dev.off(), silent=TRUE)

# Get RMSE
error <- fits %>%
  group_by(model, target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) #could also do somethign  else here

# plot rmse
gg.rmse <- error %>%
  filter(!model %in% c("fra", "fra2")) %>%
  ggplot(aes(x=model, y=.estimate, fill=model)) +
  geom_col() +
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle=45, hjust = 1)) +
  labs(x = "Model",
       y = "RMSE")+
  theme(axis.text.x = element_text(angle=45, hjust = 1))

gg.rmse

#Save figure
pdf(file="figs/model_comparisons/rmse.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.rmse)
try(dev.off(), silent=TRUE)
```

## How well do the estimated bias recover the true composition

```{r calibration}
cal <- fits %>%
    ungroup() %>%
    dplyr::mutate(calibrated = observed / estimated) %>%
    group_by(sample_id, model) %>%
    mutate_at(vars(calibrated), ~ . / sum(., na.rm=TRUE) )  %>%
    ungroup() 


gg.cal <- ggplot(cal, aes(x=taxon, y= odds(calibrated) / odds(exp_individuals), shape=target_subfragment )) +
    geom_hline(yintercept=1, alpha=0.8)+
  geom_jitter(aes(x=taxon, y= odds(observed) / odds(exp_individuals)),
              colour="grey", alpha=0.7, width = 0.1, height = 0)+
    geom_jitter(aes(colour = taxon),alpha=0.7, width = 0.1, height = 0) +
    geom_rangeframe(color = "black") + 
    scale_y_log10() + 
    facet_grid(mixture_type ~ model) +
    labs(x = "Taxon", 
        y = "Odds calbirated / expected",
        colour = "Taxon",
        shape = "Primer pair") +
    coord_flip() +
  scale_color_manual(values = colours.taxon) + 
    theme(legend.position = "bottom")

gg.cal

#Save figure
pdf(file="figs/model_comparisons/calibration.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.cal)
try(dev.off(), silent=TRUE)

```

From the above we can see that the metacal and complm models fit the data the best. We will do the rest of the analysis with the complm as the regression framework provides more flexibility

# Fit final model 

We will use bootstrapping to get a best estimate and associated confidence intervals, which will take the form of geometric mean and standard deviations of the bootstrap estimates.

Tje geometric mean and the geometric standard deviation of a sample of data from a log-normally distributed population may be used to find the bounds of confidence intervals analogously to the way the arithmetic mean and standard deviation are used to bound confidence intervals for a normal distribution.

When using geometric SD factor in conjunction with geometric mean, it should be described as "the range from (the geometric mean divided by the geometric SD factor) to (the geometric mean multiplied by the geometric SD factor), and one cannot add/subtract "geometric SD factor" to/from geometric mean

Therefore the estimated efficiencies are shown as the best estimate multiplied and divided by two geometric standard errors

```{r Final model}
lm_dat <- joint %>%
  filter(exp_individuals > 0) %>%
  group_by(mixture_type, target_subfragment) 

group_name <- group_keys(lm_dat) %>%
  unite(col="name", everything(), sep=";") %>%
  pull(name)

lm_dat <- lm_dat %>%
  group_split() %>%
  set_names(group_name)

set.seed(606)
boots <- purrr::map(lm_dat, bootstraps, times=1000, apparant=TRUE)

# Fit model to bootstraps
boot_models <- boots %>% 
  purrr::map(function(x){ 
    x <- x %>%
      mutate(lm_obj = map(splits, ~lm(center_elts(observed0 / exp_individuals) ~ 0 + taxon, data = .)), #why cant i use lm spec here?
            pred = map2(lm_obj, splits, function(.model, .data) predict(.model, .data)),
            coef_info = map(lm_obj, tidy),
            #aug = map(lm_obj, broom::augment),
            data = map(splits, function(y){
              as.data.frame(y) %>%
                dplyr::select(observed, count, mixture_type, sample_id, taxon, exp_individuals)})
        ) 
    }) 

# Get coefficients
boot_coefs <- boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(coef_info)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  mutate(taxon = str_remove(term, "taxon")) %>%
  mutate(extract_type = case_when(
      mixture_type=="DNEasy" ~ "DNEasy",
      mixture_type=="QuickExtract" ~ "QuickExtract",
      TRUE ~ "NA"
    ))%>%
    dplyr::select(!where(is.list))


#results
boot_results <- boot_models%>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(pred, data)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  dplyr::filter(exp_individuals > 0)%>% 
  mutate(
    predicted = exp_individuals * pred, 
    estimated = pred
  ) %>%
  group_by(sample_id, id) %>%
  mutate_at(vars(predicted, observed, exp_individuals), ~ . / sum(., na.rm=TRUE) ) %>% #re-close elements
  dplyr::select(!where(is.list))

# Visualise fits of predicted proportions

# Get RMSE
final_rmse <- boot_results %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) #could also do somethign  else here

final_anorm <- boot_results %>%
   mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type, id ) %>%
    summarise(Adist = anorm(observed / predicted))  %>%
  group_by(target_subfragment, mixture_type) %>%
  summarise(Adist = mean(Adist))


# Visualise fits to data
gg.final_fits <- boot_results %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  ggplot(aes(logit(predicted), logit(observed))) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_text(data=final_rmse, aes(x=-12, y=1, label=paste0("RMSE: ",round(.estimate, 2))),check_overlap = TRUE, inherit.aes = FALSE, hjust = 0)+
  geom_text(data=final_anorm, aes(x=-12, y=-1, label=paste0("A.dist: ",round(Adist, 2))),check_overlap = TRUE, inherit.aes = FALSE, hjust = 0)+
 stat_density_2d(geom = "polygon", aes(alpha = ..level.., fill = taxon))+
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_manual(values = colours.taxon) +
  scale_colour_manual(values = colours.taxon) +
  base_theme +
  theme(panel.grid = element_line(size = rel(1))) +
  scale_alpha_continuous(range=c(0.3, 0.9))+
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "none",
        legend.text = element_text(face="italic")) +
    labs(x = "Bias model prediction (log-odds)", 
        y = "Observed proportions (log-odds)",
        fill = "Taxon", 
        colour= NULL)+
  coord_cartesian(xlim = c(-12,3), ylim = c( -12, 3))

## Visualise errors in unmodelled proportions
prop_rmse <- joint %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = expected, estimate = observed) #could also do somethign  else here


prop_anorm <- joint %>%
   mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
    summarise(Adist = anorm(observed / expected)) 


gg.err_prop <- joint%>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>% 
  mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(exp_individuals,observed, color = taxon)) + 
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_text(data=prop_rmse, aes(x=-12, y=1, label=paste0("RMSE: ",round(.estimate, 2))),check_overlap = TRUE, inherit.aes = FALSE, hjust = 0)+
  geom_text(data=prop_anorm, aes(x=-12, y=-1, label=paste0("A.dist: ",round(Adist, 2))),check_overlap = TRUE, inherit.aes = FALSE, hjust = 0)+
  geom_point(alpha=0.5) +
  scale_colour_manual(values = colours.taxon) +
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Expected proportions (log-odds)", 
       y = "Observed proportions (log-odds)",
       colour = "Taxon")  +
  base_theme +
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "none",
        legend.text = element_text(face="italic")) +
    facet_grid(target_subfragment~mixture_type) +
  coord_cartesian(xlim = c(-12,3), ylim = c( -12, 3))

colours.taxon2 <- colours.taxon
names(colours.taxon2) <- names(colours.taxon) %>% str_replace("_", " ")

gg.final_ests <- boot_coefs  %>%
    group_by(taxon, target_subfragment, mixture_type) %>%
    summarise(gm_quantiles(estimate, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(estimate, na.rm=TRUE),
              gm_se = metacal::gm_sd(estimate, na.rm = TRUE)) %>%
    ungroup %>%
    mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  mutate(taxon = taxon %>% str_replace("_", " ")) %>%
  ggplot(aes(x=taxon, y=gm_mean, colour=taxon))+
  geom_pointrange(aes(ymin = gm_mean / gm_se^2, ymax = gm_mean * gm_se^2),
        fatten = 3,
        position = position_dodge(width = 0.5)) +
    scale_colour_manual(values = colours.taxon2) +
    geom_hline(yintercept = 1, colour="grey80" )  +
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x))) +
    annotation_logticks(sides="l", outside=TRUE) +
    geom_rangeframe(color = "black") +
  base_theme +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_blank(),
        legend.text = element_text(face="italic")) +
    facet_grid(target_subfragment~mixture_type) +
  labs(y = "Efficiency / geometric mean",
       x = "Taxon",
      colour = "Taxon") +
  coord_cartesian(clip = "off")

Fig1 <- gg.err_prop /  gg.final_fits / gg.final_ests  + plot_annotation(tag_levels = "A")  & theme(plot.margin =unit(c(0,0,0,0), "cm"))

Fig1

#Save figure
pdf(file="figs/fig1_bias.pdf", width = 8, height = 9 , paper="a4")
  plot(Fig1)
try(dev.off(), silent=TRUE)

```


# Bias partitioning

```{r Bias partition}
# Partition the bias in all bootstrap replicates
boot_partitioned <- boot_coefs %>%
  dplyr::filter(!extract_type=="NA") %>% 
  dplyr::select(target_subfragment,  extract_type, mixture_type,
                taxon, id, estimate) %>%
  left_join(boot_coefs %>%
  dplyr::filter(extract_type=="NA") %>%
  dplyr::select(taxon, target_subfragment, mixture_type,id, estimate) %>%
    distinct %>%
    pivot_wider(names_from = mixture_type,
              values_from=estimate)) %>%
  group_by(extract_type, target_subfragment, taxon) %>%
    transmute(bias_all = estimate,
              bias_extract = estimate / DNA,
              bias_PCR = DNA / PCR,
              bias_seq = PCR)

# Calculate bias as geometric mean, and standard error as geometric standard error of bootstrap replicates
bias_steps <- boot_partitioned %>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
    group_by(taxon, target_subfragment,extract_type, step) %>%
    summarise(gm_quantiles(bias, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(bias, na.rm=TRUE),
              gm_se = metacal::gm_sd(bias, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q"))

# Need to understand why we choose 2 geometric standard errors??
gg.bias_steps <- bias_steps %>%
  dplyr::filter(!(extract_type=="QuickExtract" & !step=="extract")) %>%
  ungroup() %>%
    mutate(extract_type = case_when(
      !step=="extract" ~ "NA",
      TRUE ~ extract_type
      )) %>%
  dplyr::filter(!step=="all") %>%
  dplyr::mutate(step = step %>% 
                  str_replace("extract", "DNA Extraction") %>%
                  str_replace("seq", "Post-PCR")) %>%
  ggplot(aes(x=taxon, y=gm_mean, shape=extract_type, colour = taxon)) +
    geom_pointrange(aes(ymin = gm_mean / gm_se^2, ymax = gm_mean * gm_se^2), #This cant be right
        fatten = 4,
        position = position_dodge(width = 1)) +
    geom_hline(yintercept = 1, colour="grey80" )  +
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x))) +
    annotation_logticks(sides="l", outside = TRUE) +
    scale_colour_manual(values = colours.taxon) +
    scale_shape_manual(values = c(17,19,8))+ 
    facet_grid(target_subfragment~step)+
  base_theme+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.text.x = element_blank(),
        legend.position = "bottom") +
      labs(x = "Contribution of laboratory step",
         y = "Efficiency / geometric mean",
         colour = "Taxon",
         shape = "DNA Extraction") +
  coord_cartesian(clip = "off")

gg.bias_steps

# Relative abundance trajectories through the workflow
ra_traj <- bias_steps %>%
    pivot_wider(names_from = step,
              values_from=starts_with("gm_")) %>%
  group_by(extract_type, target_subfragment) %>%
  transmute(taxon,
        RA_Insects = 1,
        SE_Insects = 1,
        RA_DNA = RA_Insects * gm_mean_extract, 
        SE_DNA = SE_Insects * gm_se_extract,
        RA_Amplicons = RA_DNA * gm_mean_PCR, 
        SE_Amplicons = SE_DNA * gm_se_PCR,
        RA_Libraries = RA_Amplicons * gm_mean_seq,
        SE_Libraries = SE_Amplicons * gm_se_seq
        ) %>%
  mutate(taxon = fct_reorder(taxon, RA_Libraries)) %>%
  pivot_longer(starts_with(c("RA_", "SE_")),
               names_to = c(".value", "position"),
               values_to = "abundance",
               names_pattern = "(..)(_.*$)"
               ) %>%
  mutate(position = position %>% str_remove("_") %>%
           factor(levels=c("Insects", "DNA", "Amplicons", "Libraries")))


## Plot the trajectories as small multiples with error pars

gg.ra_traj <- ra_traj %>%
  dplyr::filter(extract_type == "DNEasy") %>%
  dplyr::filter(!taxon == "Bradysia_nr.ocellaris") %>%
    ggplot(aes(x = position, y= RA, color = taxon, group=extract_type, shape=extract_type, fill=taxon)) +
    geom_hline(yintercept = 1, colour="black" )  +
    geom_line() +
    #geom_text(aes(label=paste0("x",round(RA, 1))),nudge_y=2, colour="black")+
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10(breaks = c(0.01, 1, 100),
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_color_manual(values = colours.taxon) +
    scale_fill_manual(values = colours.taxon) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "DNEasy")   +
  base_theme+
  theme(panel.grid = element_blank(),
        panel.border = element_blank(),
        axis.line.y = element_line(),
        strip.text.y = element_blank(),
        legend.position = "none")

gg.ra_traj2 <- ra_traj %>%
  dplyr::filter(extract_type == "QuickExtract") %>%
    ggplot(aes(x = position, y= RA, color = taxon, group=extract_type, shape=extract_type, fill=taxon)) +
    geom_hline(yintercept = 1, colour="black")  +
    geom_line() +
    #geom_text(aes(label=paste0("x",round(RA, 1))),nudge_y=2, colour="black")+
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10(breaks = c(0.01, 1, 100),
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_color_manual(values = colours.taxon) +
    scale_fill_manual(values = colours.taxon) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "QuickExtract") +
  base_theme+
  theme(panel.grid = element_blank(),
        panel.border = element_blank(),
        axis.line.y = element_line(),
        strip.text.y = element_blank(),
        legend.position = "none")
 

Fig2a <- gg.ra_traj + gg.ra_traj2 

Fig2 <- gg.bias_steps - Fig2a + plot_annotation(tag_levels = "A")

Fig2


#Save figure
pdf(file="figs/fig2_bias_partitioned.pdf", width = 11, height = 8 , paper="a4r")
  plot(Fig2)
try(dev.off(), silent=TRUE)

```

# Trait effects

How do specimen traits affect its efficiency

```{R prediction on partitioned}
#Predict seperated bias 
error_preds <- joint %>%
  left_join(bias_steps 
            #%>%
              #mutate(step = case_when(
              #  extract_type == "DNEasy" & step == "extract" ~ "DNEasy",
              #  extract_type == "QuickExtract" & step == "extract" ~ "QuickExtract",
              #  TRUE ~ step
              #)) %>%
              #dplyr::filter(!(extract_type == "QuickExtract" & !step == "QuickExtract"))
              ) %>%
  filter(exp_individuals > 0, mixture_type %in% c("DNEasy", "QuickExtract")) %>%
  mutate(primerdist = Fdist  + Rdist) %>%
  dplyr::rename(bias = gm_mean)

# Specify LM Recipe and map
lm_mod <-
  linear_reg(mode = "regression") %>%
  set_engine("lm")

wf <-
  workflow() %>%
  add_model(lm_mod)

## big function of model fitting and predicting
bias_coeffs <- function(df, step="all") {

  print(step)
  if(step == "extract"){
    df <- df %>% dplyr::select(bias, exoskeleton, biomass_mm3)
  } else if (step == "PCR"){
    df <-  df %>% dplyr::select(bias, primerdist, `G|C`)
  } else if(step== "seq"){
    df <-  df %>% dplyr::select(bias, `G|C`)
  } else if (step=="all"){
    df <- df
  }
  print(df)
  #create recipe
  lm_rec <- df %>%
    recipe(bias ~ ., data=df) %>%
    step_zv(all_numeric(), -all_outcomes()) %>%
    step_normalize(all_numeric()) %>%
    step_corr(all_numeric(), -all_outcomes(), threshold = 0.9) %>%
    step_lincomb(all_numeric(), -all_outcomes()) %>%
    step_dummy(all_nominal(), one_hot=TRUE) 
    
  print(prep(lm_rec))
  #fit workflow
  fit_wf <-
    wf %>%
    add_recipe(lm_rec) %>%
    fit(data = df)
  
  #Get coefficients
  fit_wf %>%
    pull_workflow_fit()  %>% 
  tidy()
}



partition_fit <- error_preds %>%
  ungroup()%>%
  filter(target_subfragment=="fwhF2-fwhR2n") %>%
  mutate(primerdist = Fdist + Rdist) %>%
  dplyr::select(bias, exoskeleton, biomass_mm3, primerdist, `G|C`, step, mixture_type) %>%
  mutate(exoskeleton= case_when(
           exoskeleton == 1 ~ "soft",
           exoskeleton == 2 ~ "medium",
           exoskeleton == 3 ~ "hard"
         ))  %>%
    mutate(exoskeleton = factor(exoskeleton, levels=c( "soft", "hard", "medium") ))%>%
  group_by(step, mixture_type)  %>% 
  nest() %>%
  #mutate(coef_info =  map2(data, step, possibly(bias_coeffs, otherwise = NA))) %>%
  mutate(coef_info =  map(data, possibly(bias_coeffs, otherwise = NA))) %>%
  unnest(coef_info) %>%
  #unnest(vi) %>%
  dplyr::select(!where(is.list)) 

gg.bias_traits <- partition_fit %>%
  dplyr::mutate(term = str_replace(term, "(Intercept)", "exoskeleton_medium")) %>%
  drop_na() %>%
  ggplot(aes(x=term, y=estimate, colour=estimate)) + 
  geom_pointrange(aes(ymax = estimate+std.error, ymin=estimate-std.error), size=0.5)+
  geom_hline(yintercept = 0)+
  facet_grid(mixture_type~step) +
  coord_flip()+
  scale_color_distiller(palette="RdYlBu")+
  base_theme+
  theme(panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        #panel.border = element_blank(),
        legend.position = "none") + 
  labs(x = "Trait",
       y = "Coefficient")

gg.bias_traits
# Plot traits on treee

# Do primer mismatch for both, take the the GC from fwh
trait_data <- error_preds %>%
  filter(target_subfragment == "fwhF2-fwhR2n") %>%
  mutate(primerdist = Fdist + Rdist) %>%
  dplyr::select(taxon, surface_mm2, biomass_mm3, exoskeleton, primerdist_fwh = primerdist, `G|C`) %>%
  distinct() %>%
    left_join(error_preds %>%
  filter(target_subfragment == "fwhF2-HexCOIR4") %>%
  mutate(primerdist = Fdist + Rdist) %>%
  dplyr::select(taxon, primerdist_hex = primerdist) %>%
  distinct())
  
tree <- read.tree("output/tree.nwk")

p1 <- ggtree(tree) + 
  #geom_tiplab() +
  geom_tippoint(aes(colour=label), size=2 ) + 
  scale_colour_manual(values = colours.taxon) +
  theme(legend.position = "none")


gg.traits <- trait_data %>%
  magrittr::set_colnames(c("taxon", "Surface area", "Biomass", "Sclerotisation", "P1 mismatch", "GC percentage","P2 mismatch")) %>%
  pivot_longer(cols=-taxon,
               names_to="trait",
               values_to="value") %>%
  left_join(
    p1$data %>%
    dplyr::select(label, y) %>%    
    dplyr::rename(taxon = label)
    ) %>%
  mutate(taxon = as.factor(taxon),
         taxon=fct_reorder(taxon, y, sum)) %>%
  mutate(trait = factor(trait, levels=c("Surface area", "Biomass", "Sclerotisation", "P1 mismatch", "P2 mismatch", "GC percentage"))) %>%
  ggplot(aes(x=taxon, y=value, fill=taxon)) +
  geom_col()+
  facet_grid(~trait, scales="free") +
  scale_fill_manual(values=colours.taxon) +
  #scale_fill_brewer(palette="Spectral")+
  coord_flip() +
  base_theme+
  theme(panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.border = element_blank(),
        axis.line.y = element_line(),
        #axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        legend.position = "none")


# Plot correlation between traits
corr <- round(cor(trait_data %>% column_to_rownames("taxon")), 1)
gg.trait_cor <- ggcorrplot(corr, hc.order = TRUE, type = "upper",
   outline.col = "white",
   lab = TRUE,
   colors = c("#4575b4", "#ffffbf", "#d73027"))+
  base_theme+
  theme(#panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.border = element_blank(),
        axis.line.y = element_line(),
        axis.line.x = element_line(),
        #axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        legend.position = "right")

# Multifig
  
Fig3a <- p1 - gg.traits - gg.trait_cor 


Fig3 <- Fig3a / gg.bias_traits + plot_annotation(tag_levels = "A")

Fig3

#Save figure
pdf(file="figs/fig3_trait_effects.pdf", width = 11, height = 8 , paper="a4r")
  plot(Fig3)
try(dev.off(), silent=TRUE)
```


# Reproducability Receipt

```{details, echo = FALSE, details.summary = 'Reproducability receipt'}
# datetime
Sys.time()

#repository
git2r::repository()

sessioninfo::session_info()
```