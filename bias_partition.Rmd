---
title: "bias_partition"
author: "Alexander Piper"
date: "19/05/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

* Comparisons of models
* Bias prediction using cofactors
  + Once bias has been partitioned to its relevant stage, we can accurately predict things
  + Can Extraction bias be predicted by scheletorization?
  + Can PCR bias be predicted by amplicon GC content, or primer binding mismatch?
  + Can library bias be predicted by PCR barcode?
  

Extra comparisons:
* Modelling of bias from # individuals vs biomass
* Modelling of contribution on partitioned vs non-partitioned bias
  + This would allow making a point that you need to partition biases to accurately improve protocols 


## Load packages
```{r load packages}
#Set required packages
.cran_packages <- c("tidyverse",
                    "tidymodels",
                    "janitor",
                    "patchwork", 
                    "vegan", 
                    "seqinr",
                    "ape", 
                    "RColorBrewer",
                    "devtools")
.bioc_packages <- c("dada2",
                    "phyloseq", 
                    "DECIPHER",
                    "Biostrings",
                    "ShortRead", 
                    "ALDEx2")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("mikemc/metacal")
devtools::install_github("wilkelab/cowplot")
devtools::install_github("clauswilke/colorblindr")
devtools::install_github("alexpiper/taxreturn")

library(metacal)
library(cowplot)
library(colorblindr)
library(taxreturn)

#Source helper functions
source("R/helper_functions.R")
```

# Set a colour scheme & Define theme

```{r pick colours}
colours.taxon <- c(
  "Acizzia_alternata" = "#FFFFFF",
  "Acizzia_solanicola" = "#C0C0C0",
  "Aphidius_colemani" = "#808080",
  "Bactrocera_tryoni" = "#000000",
  "Bradysia_ocellaris" = "#FF0000",
  "Carpophilus_davidsoni" = "#800000",
  "Carpophilus_nr_dimidiatus" = "#FFFF00",
  "Diuraphis_noxia" = "#808000",
  "Drosophila_hydeii" = "#00FF00"  ,
  "Drosophila_melanogaster" = "#008000",
  "Drosophila_simulans" = "#00FFFF",
  "Lysiphlebus_testaceipes" = "#008080",
  "Metopolophium_dirhodum" = "#0000FF",
  "Psyllid_sp" = "#000080",
  "Rhopalosiphum_padi" = "#FF00FF",
  "Scaptodrosophila_lativittata" = "#800080"
) 

scales::show_col(colours.taxon)


#Source themes
source('R/themes.R')
```

# Read in data & get summary statistics

```{R read in}
counts <- read_csv("R_analysis/FILE_for_R_NEW.csv") %>%
  janitor::clean_names() %>%
  dplyr::mutate(sample_id = paste0(sample, "_", run),
                mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  TRUE ~ mixture_type
                  ),
                target_subfragment = case_when(
                  str_detect(sample, "P1$") ~ "fwhF2-fwhR2n",
                  str_detect(sample, "P2$") ~ "fwhF2-HexCOIR4",
                )) %>% #Add new sample_id column t
  dplyr::select(-table) 

# Check all are proportions  
counts %>%
  group_by(sample, run) %>%
  summarise(exp = sum(expected), obs = sum(observed), count = sum(count))

# N unique species and samples
 counts %>%
  summarise(n_samples = n_distinct(sample), n_sequenced_samples = n_distinct(sample_id))

# Spread of reads
counts %>%
  group_by(sample_id) %>%
  summarise(exp_prop = sum(expected), obs_prop = sum(observed), Abundance = sum(count)) %>%
  ungroup() %>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance),
            exp_prop = mean(exp_prop),
            obs_prop = mean(obs_prop))

```

## Add species traits

```{r biomass transform}
traits <- readxl::read_excel("biomass and hardness.xlsx")  %>%
  janitor::clean_names() %>%
  dplyr::rename(taxon = species) %>%
  filter(!is.na(taxon)) %>%
  dplyr::mutate(taxon = taxon %>%
                  str_replace("C\\.", "Carpophilus") %>%
                  str_replace("D\\.", "Drosophila") %>%
                  str_replace("A\\.", "Acizzia") %>%
                  str_replace("dimidiatis", "dimidiatus") %>%
                  str_replace("hydeii", "hydei") %>%
                  str_replace_all(" ", "_") %>%
                  str_remove_all("\\.")
                  ) %>%
  dplyr::mutate(exoskeleton = as.numeric(exoskeleton))

# Plot measured traits
traits %>%
  pivot_longer(-c("taxon", "order"), 
               names_to = "trait",
               values_to = "value") %>%
  ggplot(aes(x=taxon, y=value, fill=order)) + 
  geom_col() +
  facet_grid(~trait) + 
  coord_flip() +
  scale_fill_brewer(palette="Paired")

#Check for differencess in taxon names
setdiff(traits$taxon, counts$taxon)
setdiff(counts$taxon, traits$taxon)

# Join tables together
joint <- counts %>%
  dplyr::mutate(taxon = taxon %>%
                  str_replace("_dimidiatus", "_nr_dimidiatus") %>%
                  str_replace("hydeii", "hydei")) %>%
  left_join(traits%>%
            mutate(taxon = taxon %>% str_replace("hydeii", "hydei")), by="taxon") %>%
  dplyr::mutate(exp_individuals = expected,
                exp_individuals = expected * biomass_mm3) %>%
  group_by(sample_id) %>%
    mutate_at(vars(exp_individuals, exp_individuals, observed), ~ . / sum(.) ) %>% #Convert back to proportions
  ungroup() %>%
  mutate(observed0 = (count + 0.5) * (expected > 0)) %>% #Add a pseudocount
  mutate(err_biomass = observed0 / exp_individuals,
         err_individuals = observed0 / exp_individuals) %>%
  ungroup() 

# Check if any werent properly joined
table(is.na(joint$exp_individuals))

# Plot expected individuals vs expected biomass
gg.p1 <- joint %>%
  dplyr::filter(target_subfragment=="fwhF2-fwhR2n") %>% #Filter to primer1
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - fwhR2n")

gg.p2 <- joint %>%
  dplyr::filter(target_subfragment =="fwhF2-HexCOIR4") %>% 
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - HexCOIR4")

gg.p1 + gg.p2
```

## Add sequence traits

```{r sequence traits}
# Get PHMM of full folmer region
coi_model <- readRDS("reference/folmer_fullength_model.rds")

primers <- tribble(
  ~Fname, ~Fprimer, ~Rname, ~Rprimer,
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "fwhR2n","GTRATWGCHCCDGCTARWACWGG",
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "HexCOIR4", "TATDGTRATDGCHCCNGC", 
  ) %>%
    left_join(.$Fprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, minscore=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("F",.)), by="Fprimer") %>%
    left_join(.$Rprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, minscore=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("R",.)), by="Rprimer")

# Read in sequences
seqs <- insect::readFASTA("reference/mock_spp2.fa")
seqnames <- names(seqs) %>%
  str_replace("Bradysia_near_ocellaris","Bradysia_ocellaris")

#Check for differencess in taxon names
setdiff(seqnames, joint$taxon)
setdiff(joint$taxon, seqnames)

names(seqs) <- seqnames

# Add primers to seqs
primers.dna <- insect::char2dna(c("GGDACWGGWTGAACWGTWTAYCCHCC", rc("GTRATWGCHCCDGCTARWACWGG"),rc("TATDGTRATDGCHCCNGC")))
names(primers.dna) <- c("fwhF2", "fwhR2n", "HexCOIR4")

#Join to seqs
seqs <- c(seqs, primers.dna)

# Trim seqs to Fprimer bind region and get primer edit distance
aligned <- taxreturn::map_to_model(seqs, coi_model, minscore = 0, shave= TRUE, pad=TRUE, check_indels=FALSE, maxNs=Inf, cores=1, quiet=FALSE)

#Transform to DNAstringSet
aligned <- aligned %>% as.list %>% as.character %>% lapply(., paste0, collapse = "") %>% 
            unlist %>% DNAStringSet

# Check alignment
BrowseSeqs(aligned)

#Get forward dist
Fprimerdist <- Biostrings::subseq(aligned, start=primers$Fstart[1], end = primers$Fend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Fprimer") %>%
  pivot_longer(cols=-Fprimer,
               names_to="taxon",
               values_to="Fdist") %>%
  filter(Fprimer=="fwhF2", !taxon %in% names(primers.dna)) %>%
  filter(Fdist < 0.5) #Filter bad alignments

#Get reverse dist
Rprimerdist <- bind_rows(
  #Rprimer1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[1]],
                     start=primers$Rstart[1], end = primers$Rend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="fwhR2n", !taxon %in% names(primers.dna)),
  #Rprimer2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[2]],
                   start=primers$Rstart[2], end = primers$Rend[2]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="HexCOIR4", !taxon %in% names(primers.dna))
)%>%
  filter(Rdist < 0.5) #Filter bad alignments

# get amplicon gc content
primergc <- bind_rows(
  #primer set 1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[1]],
                     start=primers$Fend[1]+1, end = primers$Rstart[1])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[1]]),
         target_subfragment = paste0(primers$Fname[1], "-", primers$Rname[1])) %>%
  dplyr::filter(!taxon %in% names(primers.dna)),
  #primer set 2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[2]],
                   start=primers$Fend[2]+1, end = primers$Rstart[2])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[2]]),
         target_subfragment = paste0(primers$Fname[2], "-", primers$Rname[2])) %>%
  dplyr::filter(!taxon %in% names(primers.dna))
)

joint <- joint %>%
  separate(target_subfragment, into=c("Fprimer", "Rprimer"), sep="-", remove=FALSE) %>%
  left_join(Fprimerdist) %>%
  left_join(Rprimerdist) %>%
  left_join(primergc) 
```

## Look at differences between runs

```{r run differences}
# Plot differences in quickextract - non-quickextract between runs
gg.runra <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
    ggplot(aes(x=sample, y=value, fill=taxon)) +
    geom_col(position="stack") +
    facet_grid(run~mixture_type, scales="free") +
    scale_fill_manual(values = colours.taxon) +
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_y_continuous(labels = scales::percent) +
    labs(x="Sample", y="Relative abundance", title="Differences in relative abundances between protocols/runs")

#Write out
pdf(file="figs/RA_between_runs.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.runra)
try(dev.off(), silent=TRUE)

# Plot as heatmap
gg.runhmap <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
  mutate(value = na_if(value, 0)) %>%
    ggplot(aes(x=sample, y=taxon, fill=value)) +
    geom_tile() +
    facet_grid(run~mixture_type, scales="free") +
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_fill_viridis_c(labels = scales::percent) +
    labs(x="Sample",
         y="Taxon",
         fill="Relative abundance",
         title="Consistency between runs")

#Write out
pdf(file="figs/heatmap_between_runs.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.runhmap)
try(dev.off(), silent=TRUE)

# Remove the quickextract samples from run 2
joint <- joint %>%
  dplyr::filter(!(mixture_type=="QuickExtract" & run==2))
```

DNApools and PCR pools 1-4 and 5-8 arent exact replicates because of the extra species that were found

## Visualise bias

```{r visualise bias}
## Visualise errors in proportions
gg.err_prop <- joint %>% 
  mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(observed, exp_individuals, color = taxon)) + 
  geom_jitter(alpha=0.7) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  scale_colour_manual(values = colours.taxon) +
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Observed proportions (log-odds)", 
       y= "Expected proportions (log-odds)",
       colour = "Taxon") 

#Write out
pdf(file="figs/err_proportions.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_prop)
try(dev.off(), silent=TRUE)

# Visualise the error in all pairwise ratios
gg.err_ratio <- joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  mutate(Pair = paste(Taxon.x, Taxon.y, sep = ":")) %>% 
  ggplot(aes(Pair, err_biomass, colour=sample_id)) +
  geom_jitter(alpha=0.7) +
  geom_hline(yintercept = 1) +
  scale_y_log10() +
  facet_grid(target_subfragment~mixture_type)+
    theme(legend.position = "none",
          axis.text.x = element_text(angle=45, hjust=1))+
  labs(y= "Error in taxon ratios (log10)") 

gg.err_ratio

#Save figure
pdf(file="figs/err_ratio.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_ratio)
try(dev.off(), silent=TRUE)
```


# Estimate bias using different models

We will now estimate the bias using different conventional and CODA models

## Francescos original analysis

```{r francescos analysis}
fit_fra <- readxl::read_excel("francescos_estimates.xlsx") %>%
  mutate(taxon = taxon %>% str_replace(" ", "_") %>%
           str_replace("dimidiatus", "nr_dimidiatus")%>%
           str_replace("Psyllid_sp.", "Psyllid_sp")%>%
           str_replace("Drosophila_hydeii", "Drosophila_hydei")) 

#results
fra_results <- joint %>%
  dplyr::filter(exp_individuals> 0) %>%
  left_join(fit_fra) %>%
  mutate(
    predicted = exp_individuals * bias, 
    observed = observed,
    estimated = bias
  ) %>%
  ungroup() %>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
```

## Recreate Francescos
* First divide the total reads per sample to get expected reads per taxon per sample
* Then calculate variation from expected reads per taxon per sample
* Then average all varation by species

```{r recreate francescos analysis}
# get expected reads per taxon per sample
fit_fra2 <- joint %>%
  group_by(sample_id) %>%
  filter(expected > 0) %>%
  mutate(total = sum(count),
         exp_counts = total * expected,
         err_counts = (count - exp_counts) * 100 / total)  %>% #Why are we doing this??
  ungroup %>%
  group_by(taxon, mixture_type, target_subfragment) %>%
  summarise(.pred = mean(err_counts))

#results
fra2_results <- joint %>%
  dplyr::filter(exp_individuals > 0) %>%
  left_join(fit_fra2) %>%
  mutate(
    predicted = exp_individuals * .pred, 
    observed = observed,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) )

```

## Mean proportions

Here we estimate bias as the arithmetic mean of the error in proportions

```{r mean proportions}
# Compare these fits!  
fit_prop <- joint %>%
  filter(expected > 0) %>%
  mutate(error = observed / exp_individuals) %>%
  group_by(mixture_type, target_subfragment, taxon) %>%
  summarise(.pred = mean(error))

#results
prop_results <- joint %>%
  dplyr::filter(expected > 0) %>%
  left_join(fit_prop) %>%
  mutate(
    predicted =  exp_individuals * .pred, 
    observed = observed,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
```

## simple lm

Here we estimate bias using a simple linear regression model of the expected and observerd proportions. The model is fit seperately to each taxon and material type.


```{r simple lm}
# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm")
lm_spec

fit_lm <- joint %>%
  filter(expected > 0) %>%
  group_by(taxon, target_subfragment, mixture_type) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, observed ~ 0 + exp_individuals, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    ) %>%
  unnest(coef_info)

#results
lm_results <- fit_lm %>%
  unnest(pred, data) %>%
  mutate(
    predicted = .pred
  ) %>%
    dplyr::select(!where(is.list))
```

## clrlm

Here we fit a simple linear model to centred log ratio transformed error vectors, using taxon as the predictor

```{r clr}
fit_clrlm <- joint %>%
  filter(expected > 0) %>%
  group_by(sample_id, target_subfragment, mixture_type) %>%
  mutate(clr_error = metacal::clr(observed0) / metacal::clr(exp_individuals)) %>%
  ungroup() %>%
  group_by(target_subfragment, mixture_type) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, clr_error ~ 0 + taxon, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    ) 

#results
clrlm_results <- fit_clrlm %>%
  unnest(pred, data) %>%
  dplyr::filter(exp_individuals > 0)  %>%
  mutate(
    predicted = exp_individuals * .pred,
    estimated = .pred
  ) %>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) )  %>% 
    dplyr::select(!where(is.list))
```

## Complm

Estimating bias  is complicated by the compositional nature of metabarcoding measurements. Because only relative abundances are measured, the measurement of a  sample (s) only provides information about the efficiencies of the taxa in the sample relative to each other.

Here we fit a simple linear model on the compositional difference between Observed and Expected counts. The compositional error vectors are first geometrically centered, then taxon is used as a predictor.

```{R compositional regressions}
fit_complm <- joint %>%
  filter(exp_individuals > 0) %>%
  group_by(mixture_type, target_subfragment)  %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, center_elts(observed0 / exp_individuals) ~ 0 + taxon, data = .)),
           pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy)
    )

#results
complm_results <- fit_complm %>%
  unnest(pred, data) %>%
  dplyr::filter(exp_individuals > 0)%>% 
  mutate(
    predicted = exp_individuals * .pred, 
    estimated = .pred
  ) %>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
  dplyr::select(!where(is.list))

complm_results %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)
```

## metacal

Here we use the bias estimation approach of *McLaren, M. R., Willis, A. D., & Callahan, B. J. (2019). Consistent and correctable bias in metagenomic sequencing experiments. Elife, 8.* This approach treats the abundances and errors as compositional vectors and estimates the bias as the geometric center of these bias vectors. 

This is a compositionally appropriate alternative to taking the arithmetic mean of errors in proportions as above.

```{R metacal}
fit_metacal <- joint %>%
   group_by(target_subfragment, mixture_type) %>%
    nest() %>%
    mutate(
        fit = map(data, function(x){
        err_mat <- x %>%
          dplyr::select(sample_id, taxon, err_individuals) %>%
          pivot_wider(id_cols= sample_id,
                      names_from = "taxon",
                      values_from = "err_individuals",
                      values_fill = list(error=NaN)) %>%
          column_to_rownames("sample_id") %>%
          as.matrix() 
        rows_to_keep <- rowSums(err_mat, na.rm=TRUE) > 0
        cols_to_keep <- colSums(err_mat, na.rm=TRUE) > 0
        err_mat <- err_mat[rows_to_keep, cols_to_keep]
        #Fit different metacal centering methods
        center(err_mat, method="proj", enframe=TRUE) %>%
        magrittr::set_colnames(c("taxon", ".pred"))
        })) %>%
    unnest(fit) 

#results
metacal_results <- joint %>%
  left_join(fit_metacal) %>%
  dplyr::filter(exp_individuals> 0) %>% 
  mutate(
    predicted = exp_individuals * .pred,
    estimated = .pred
  )%>%
  group_by(sample_id) %>%
  mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
  dplyr::select(!where(is.list))

metacal_results %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted)
```

# Evaluate all model fits

Here we compare the accuracy of the bias estimation procedure by looking at the Root Mean Square Error (RMSE) between the observed relative abundances from sequencing, and the predicted relative abundances (Expected * Bias estimate) from each model.

To determine the models predictive ability to new data, we also determine these metrics for a seperate testing set of samples that the model was not trained on.

```{R model comparison}
all_fits <- do.call("list", mget(grep("_results",names(.GlobalEnv),value=TRUE))) %>%
  bind_rows(.id="model") 

fits <- all_fits %>%
  mutate(model = model %>%
           str_remove("_results")) %>%
  dplyr::select(model, taxon, mixture_type, target_subfragment, sample_id, run, exp_individuals, observed, predicted, estimated) 

# Plot bias estimates
gg.bias_ests <- fits %>%
  ggplot(aes(taxon, y=estimated-1, fill=model, group=model)) +
    geom_col(position=position_dodge(width=0.9))+
    facet_grid(target_subfragment~mixture_type, scales="free") +
  coord_flip() +
  scale_fill_brewer(palette="Paired") +
  labs(
    x = "Taxon",
    y = "Bias estimate",
    fill="Model")

gg.bias_ests

#Save figure
pdf(file="figs/bias_estimates.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.bias_ests)
try(dev.off(), silent=TRUE)
```

## How well do the bias models explain the data?

```{r model fits}
# Visualise fits to data
gg.bias_preds <- fits %>%
  ggplot(aes(logit(predicted), logit(observed), color = taxon, shape=target_subfragment)) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_point(alpha = 0.5) +
  coord_fixed() + 
  facet_grid(mixture_type~model) +
  scale_color_manual(values = colours.taxon) +
  theme(legend.position = "bottom")+
    labs(x = "log-odds(Predicted proportion)", 
        y = "log-odds(Observed proportion)",
        colour = "Taxon",
        shape = "Primer pair",
        title="Bias model fits") 

gg.bias_preds

#Save figure
pdf(file="figs/bias_preds.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.bias_preds)
try(dev.off(), silent=TRUE)

# Get RMSE
error <- fits %>%
  group_by(model, target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) #could also do somethign  else here

# plot rmse
gg.rmse <- error %>%
  filter(!model %in% c("fra", "fra2")) %>%
  ggplot(aes(x=model, y=.estimate, fill=model)) +
  geom_col() +
  base_theme+
  geom_rangeframe() +
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle=45, hjust = 1)) +
  labs(x = "Model",
       y = "RMSE")+
  theme(axis.text.x = element_text(angle=45, hjust = 1))

gg.rmse

#Save figure
pdf(file="figs/rmse.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.rmse)
try(dev.off(), silent=TRUE)
```

## How well do the estimated bias recover the true composition

```{r calibration}
cal <- fits %>%
    ungroup() %>%
    dplyr::mutate(calibrated = observed / estimated) %>%
    group_by(sample_id, model) %>%
    mutate_at(vars(calibrated), ~ . / sum(., na.rm=TRUE) )  %>%
    ungroup() 


gg.cal <- ggplot(cal, aes(x=taxon, y= odds(calibrated) / odds(exp_individuals), shape=target_subfragment )) +
    geom_hline(yintercept=1, alpha=0.8)+
  geom_jitter(aes(x=taxon, y= odds(observed) / odds(exp_individuals)),
              colour="grey", alpha=0.7, width = 0.1, height = 0)+
    geom_jitter(aes(colour = taxon),alpha=0.7, width = 0.1, height = 0) +
    geom_rangeframe(color = "black") + 
    scale_y_log10() + 
    facet_grid(mixture_type ~ model) +
    labs(x = "Taxon", 
        y = "Odds calbirated / expected",
        colour = "Taxon",
        shape = "Primer pair") +
    coord_flip() +
  scale_color_manual(values = colours.taxon) + 
    theme(legend.position = "bottom")

gg.cal

#Save figure
pdf(file="figs/calibration.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.cal)
try(dev.off(), silent=TRUE)

```

From the above we can see that the metacal and complm models fit the data the best. We will do the rest of the analysis with the complm as the regression framework provides more flexibility

# Partition the bias using complm

We will use bootstrapping to get a best estimate and associated confidence intervals, which will take the form of geometric mean and standard deviations of the bootstrap estimates.

Tje geometric mean and the geometric standard deviation of a sample of data from a log-normally distributed population may be used to find the bounds of confidence intervals analogously to the way the arithmetic mean and standard deviation are used to bound confidence intervals for a normal distribution.

When using geometric SD factor in conjunction with geometric mean, it should be described as "the range from (the geometric mean divided by the geometric SD factor) to (the geometric mean multiplied by the geometric SD factor), and one cannot add/subtract "geometric SD factor" to/from geometric mean

Therefore the estimated efficiencies are shown as the best estimate multiplied and divided by two geometric standard errors

```{r Bias partitioning}
lm_dat <- joint %>%
  filter(exp_individuals > 0) %>%
  group_by(mixture_type, target_subfragment) 

group_name <- group_keys(lm_dat) %>%
  unite(col="name", everything(), sep=";") %>%
  pull(name)

lm_dat <- lm_dat %>%
  group_split() %>%
  set_names(group_name)

set.seed(606)
boots <- purrr::map(lm_dat, bootstraps, times=1000, apparant=TRUE)

# Fit model to bootstraps
boot_models <- boots %>% 
  purrr::map(function(x){ 
    x <- x %>%
      mutate(lm_obj = map(splits, ~lm(center_elts(observed0 / exp_individuals) ~ 0 + taxon, data = .)), #why cant i use lm spec here?
            pred = map2(lm_obj, splits, function(.model, .data) predict(.model, .data)),
            coef_info = map(lm_obj, tidy),
            aug = map(lm_obj, broom::augment) 
        ) 
    }) 

# Get coefficients
boot_coefs <- boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(coef_info)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  mutate(taxon = str_remove(term, "taxon")) %>%
  mutate(extract_type = case_when(
      mixture_type=="DNEasy" ~ "DNEasy",
      mixture_type=="QuickExtract" ~ "QuickExtract",
      TRUE ~ "NA"
    ))%>%
    dplyr::select(!where(is.list))


# Partition the bias in all bootstrap replicates
boot_partitioned <- boot_coefs %>%
  dplyr::filter(!extract_type=="NA") %>% 
  dplyr::select(target_subfragment,  extract_type, mixture_type,
                taxon, id, estimate) %>%
  left_join(boot_coefs %>%
  dplyr::filter(extract_type=="NA") %>%
  dplyr::select(taxon, target_subfragment, mixture_type,id, estimate) %>%
    distinct %>%
    pivot_wider(names_from = mixture_type,
              values_from=estimate)) %>%
  group_by(extract_type, target_subfragment, taxon) %>%
    transmute(bias_extract = estimate / DNA,
           bias_PCR = DNA / PCR,
           bias_seq = PCR)

# Calculate bias as geometric mean, and standard error as geometric standard error of bootstrap replicates
bias_steps <- boot_partitioned %>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
    group_by(taxon, target_subfragment,extract_type, step) %>%
    summarise(gm_quantiles(bias, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(bias, na.rm=TRUE),
              gm_se = metacal::gm_sd(bias, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q"))

# Need to understand why we choose 2 geometric standard errors??
gg.bias_steps <- bias_steps %>%
  dplyr::filter(!(extract_type=="QuickExtract" & !step=="extract")) %>%
  ungroup() %>%
    mutate(extract_type = case_when(
      !step=="extract" ~ "NA",
      TRUE ~ extract_type
      )) %>%
  ggplot(aes(x=step, y=gm_mean, shape=extract_type, colour = taxon)) +
    geom_pointrange(aes(ymin = gm_mean / gm_se^2, ymax = gm_mean * gm_se^2), #This cant be right
        fatten = 4,
        position = position_dodge(width = 0.5)) +
    geom_hline(yintercept = 1, colour="grey80" )  +
    scale_y_log10() +
    geom_rangeframe(color = "black") +
    scale_colour_manual(values = colours.taxon) +
    scale_shape_manual(values = c(17,19,8))+ 
    facet_grid(target_subfragment~.)+
    labs(x = "Contribution of laboratory step",
         y = "Efficiency / geometric mean",
         colour = "Taxon",
         shape = "DNA Extraction") + 
  theme(legend.position = "bottom")

gg.bias_steps

#Save figure
pdf(file="figs/bias_steps.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.bias_steps)
try(dev.off(), silent=TRUE)
  
# Relative abundance trajectories through the workflow
ra_traj <- bias_steps %>%
    pivot_wider(names_from = step,
              values_from=starts_with("gm_")) %>%
  group_by(extract_type, target_subfragment) %>%
  transmute(taxon,
        RA_Insects = 1,
        SE_Insects = 1,
        RA_DNA = RA_Insects * gm_mean_extract, 
        SE_DNA = SE_Insects * gm_se_extract,
        RA_Amplicons = RA_DNA * gm_mean_PCR, 
        SE_Amplicons = SE_DNA * gm_se_PCR,
        RA_Libraries = RA_Amplicons * gm_mean_seq,
        SE_Libraries = SE_Amplicons * gm_se_seq
        ) %>%
  mutate(taxon = fct_reorder(taxon, RA_Libraries)) %>%
  pivot_longer(starts_with(c("RA_", "SE_")),
               names_to = c(".value", "position"),
               values_to = "abundance",
               names_pattern = "(..)(_.*$)"
               ) %>%
  mutate(position = position %>% str_remove("_") %>%
           factor(levels=c("Insects", "DNA", "Amplicons", "Libraries")))

# make plot
gg.ra_traj <- ra_traj %>%
    ggplot(aes(position, RA, color = taxon)) +
    geom_hline(yintercept = 1, colour="grey80")  +
    geom_path(aes(group = taxon)) +
    geom_point() +
    scale_y_log10() +
    geom_rangeframe(color = "black") +
    scale_color_manual(values = colours.taxon) +
  facet_grid(target_subfragment~extract_type)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "Relative abundance trajectories") + 
  theme(legend.position = "bottom")
  
gg.ra_traj

#Save figure
pdf(file="figs/ra_trajectories.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.ra_traj)
try(dev.off(), silent=TRUE)

## Plot the trajectories as small multiples with error pars

gg.ra_traj2 <- ra_traj %>%
    ggplot(aes(x = position, y= RA, color = extract_type, group=extract_type, shape=extract_type, fill=extract_type)) +
    geom_hline(yintercept = 1, colour="grey80" )  +
    geom_line() +
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10() +
    #scale_color_manual(values = colours.taxon) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Step in the workflow",
          y = "Abundance / geometric mean", 
          colour = "Taxon",
        title = "Relative abundance trajectories") + 
  theme(legend.position = "bottom")
  
gg.ra_traj2 
```

# Next - model partitioned bias as a function of species traits
: First,
how do the traits of the taxon (size, sclerotization) affect its probability of detection (presence/absence) in the two types of samples?
Second, how do the traits of the taxon affect its relative read count
in the two types of samples?
To answer the first question, we used a generalized linear
mixed effects model of presence as a function of fixed effects
Sample type (ethanol or tissue), size and sclerotization, along with
all two‐ and three‐way interactions. To account for the paired design (where both types of samples were derived from the same
Malaise trap catches), we defined Sample ID as a random effect.
Since the response was binomial, we assumed a logit‐link and binomially distributed error.

#

  + Can Extraction bias be predicted by scheletorization?
  + Can PCR bias be predicted by amplicon GC content, or primer binding mismatch?
  + Can library bias be predicted by PCR barcode?

# Predict bias from pcr mismatch and gc content

We focused on the log ratio between actual and observed 

formula R = log{(nO + 0.5)/(nA + 0.5)} 
where R is the response
where nA is the taxon‐ and sample‐specific read count (Observed compositions) from the
sequencing, and nA is the actual proportion of biomass for that taxon in the sample

```{R prediction on partitioned}
#Predict seperated bias 
error_preds <- joint %>%
  left_join(bias_steps) %>%
  filter(exp_individuals > 0, mixture_type %in% c("DNEasy", "QuickExtract")) %>%
  mutate(primerdist = Fdist  + Rdist) %>%
  dplyr::rename(bias = gm_mean)

# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm") %>%
  step_normalize(all_numeric()) %>%
  step_dummy(taxon, exoskeleton) 
lm_spec

partition_fit <- error_preds %>%
  mutate(#Fdist = replace_na(Fdist, 0), #NAs are actual missing data
         #Rdist = replace_na(Rdist, 0),
         primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  group_by(step)  %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ exoskeleton + biomass_mm3 + primerdist + `G|C`, data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)  %>%
  #unnest(vi) %>%
  dplyr::select(!where(is.list)) 

#VI default for linear model is based on the absolute value of the t-statistic

# Interestingly some nonsensical values are significant for some steps - ie primerdist is significant for extract
# This could either be because of correlation/colinearity with a more important predictor, or show that bias has not been properly partitioned

#%>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

#Fit for seperate partitions
extract_fit <- error_preds %>%
  filter(step=="extract") %>%
  mutate(primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ 1 + exoskeleton + biomass_mm3 , data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)%>%
  #dplyr::select(!where(is.list))  %>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

## QUestion - what does surface mm2 represent?

# PCR fit
pcr_fit <- error_preds %>%
  filter(step=="PCR") %>%
  mutate(primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ 1 + primerdist  + `G|C` , data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)%>%
  #dplyr::select(!where(is.list))  %>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

# sequencing fit
seq_fit <- error_preds %>%
  filter(step=="seq") %>%
  mutate(primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, bias ~ 1 + primerdist  + `G|C` , data = .)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )%>%
  unnest(coef_info)%>%
  #dplyr::select(!where(is.list))  %>%
  mutate(signif = case_when(
    p.value <0.05 ~ TRUE,
    p.value > 0.05 ~ FALSE
  ))

```

### TRY WITH FULL MDOEL!

Doesnt work because of colienarity - ie these other factors are a function of taxon and therefore totally colinear
```{r}
# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm") %>%
  step_normalize(all_numeric()) %>%
  step_dummy(taxon, exoskeleton) 
lm_spec

fit_complm <- joint %>%
  filter(exp_individuals > 0) %>%
  mutate(#Fdist = replace_na(Fdist, 0), #NAs are actual missing data
         #Rdist = replace_na(Rdist, 0),
         primerdist = Fdist + Rdist,
         exoskeleton = as.factor(exoskeleton),
         taxon = as.factor(taxon),
         primerdist) %>%
  group_by(mixture_type, target_subfragment)  %>%
  nest() %>%
  mutate(lm_obj = map(data, ~fit(lm_spec, center_elts(observed0 / exp_individuals) ~ exoskeleton + biomass_mm3 + primerdist + `G|C`, data = .)),
           #pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data)),
           coef_info = map(lm_obj, tidy),
           vi = map(lm_obj, vip::vi)
    )

test <-fit_complm %>%
  unnest(coef_info)%>%
    dplyr::select(!where(is.list))
  
  
  boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(vi)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";")%>%
    dplyr::select(!where(is.list))



```



```{r bias preiction}
# Predict bias of the whole communties
bias <- boot_coefs  %>%
    dplyr::filter(!extract_type=="NA") %>%
    group_by(taxon, target_subfragment, extract_type) %>%
    summarise(gm_quantiles(estimate, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(estimate, na.rm=TRUE),
              gm_se = metacal::gm_sd(estimate, na.rm = TRUE)) %>%
    ungroup 

%>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
    group_by(taxon, target_subfragment,extract_type, step) %>%
    summarise(gm_quantiles(bias, q = c(0.05, 0.5, 0.95), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(bias, na.rm=TRUE),
              gm_se = metacal::gm_sd(bias, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q"))

#Predict on whole insect pools - want to rpedict the different bias
traits <- joint %>%
  left_join(bias) %>%
  filter(exp_individuals > 0, mixture_type %in% c("DNEasy", "QuickExtract")) %>%
  mutate(primerdist = Fdist  + Rdist)

```



# PCA plot of whole composition through process

Recreate process

See CJ batteys spacetree plot for how to plot this: https://github.com/cjbattey/spacetree/blob/master/spacetree.R

```{r}
test <- joint %>%
  dplyr::select(sample_id, taxon, exp_individuals, target_subfragment) %>%
  distinct() %>%
  left_join(bias_steps %>%
    pivot_wider(names_from = step,
              values_from=starts_with("gm"))) %>%
  group_by(extract_type, target_subfragment, sample_id) %>%
  mutate(
        T_Insects = exp_individuals,
        T_DNA = T_Insects * gm_mean_extract, 
        T_Amplicons = T_DNA * gm_mean_PCR, 
        T_Libraries = T_Amplicons * gm_mean_seq,
        ) %>%
  dplyr::select(-starts_with("gm_"), -exp_individuals) %>%
  mutate(taxon = fct_reorder(taxon, T_Libraries)) %>%
  pivot_longer(starts_with("T_"),
               names_to = "position",
               values_to = "abundance"
               ) %>%
  mutate(position = position %>% str_remove("T_") %>%
           factor(levels=c("Insects", "DNA", "Amplicons", "Libraries"))) %>%
  mutate(abundance = clr(abundance))

#PCA
test2 <- test %>% 
  ungroup %>%
  pivot_wider(names_from = taxon,
              values_from = abundance,
              values_fill = list(abundance=0)) 


pca_rec <- recipe(~., data = test2) %>%
  update_role(extract_type, target_subfragment, position, sample_id, new_role = "id") %>%
  step_normalize(all_predictors()) %>%
  step_pca(all_predictors())

pca_prep <- prep(pca_rec)

pca_prep

#Look at contributions to components
tidied_pca <- tidy(pca_prep,2) # 1 is for  step 1

tidied_pca %>%
  filter(component %in% paste0("PC", 1:5)) %>%
  mutate(component = fct_inorder(component)) %>%
  ggplot(aes(value, terms, fill = terms)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~component, nrow = 1) +
  labs(y = NULL) 

# Plot PCA
juice(pca_prep) %>%
  ggplot(aes(PC1, PC2, label = sample_id)) +
  geom_point(aes(color = position), alpha = 0.7, size = 2) +
  geom_text(check_overlap = TRUE, hjust = "inward", family = "IBMPlexSans") +
  facet_grid(~position) %>%
  labs(color = NULL)

# 3d PCA

library(scatterplot3d)

test3 <- juice(pca_prep) %>%
  mutate(timepoint = case_when(
    position=="Insects" ~ 1,
    position=="DNA" ~ 2,
    position=="Amplicons" ~ 3,
    position=="Libraries" ~ 4
  )) %>%
  mutate(timepoint = as.factor(timepoint)) %>%
  dplyr::select(-PC3, -PC4, -PC5)

colors <- unname( colours.taxon[6:9])
colors <- colors[as.numeric(test3$timepoint)]
scatterplot3d(test3[,c(7,5,6)], grid=TRUE,pch=20, box=FALSE, color = colors )
```


# Reproducability Receipt

```{details, echo = FALSE, details.summary = 'Reproducability receipt'}
# datetime
Sys.time()

#repository
git2r::repository()

sessioninfo::session_info()
```

# EXTRA

### Linear model on compositional vector

Type of noise in our system we need to model:
Random multiplicative error (PCR?)
Random counting error (Multinomial) - read counts normalised to proportions
or 
Random counting error (Poisson)

##Generalised linear regression model

The goal is to distinguish between samples and  the underlying communities
* n samples, Q taxa, and p parameters
* X is an nxp matrix of sample covariates (ie a model matrix)
* Xi is a px1 column vector of covariates for sample i
* R is a pxQ matrix of composition and bias parameters

X = model.matrix(~ 0 + Specimen + Protocol, sam)
